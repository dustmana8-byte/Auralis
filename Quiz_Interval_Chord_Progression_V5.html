<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Music Ear Training for RCM Level 8 Exam (Sequence Mode)</title>
  <style>
    :root{
      --accent-green: #2ecc71; /* brighter green */
      --accent-green-strong: #21c46a;
      --accent-red: #ff4757;   /* brighter red */
      --nav-bg: #f3f3f3;
      --nav-text-dim: #666;
    }

    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 1rem; max-width: 1000px; margin: auto; }
    h1 { margin-bottom:.2rem; }
    .controls-row { display:flex; gap:.5rem; align-items:center; margin-bottom: .6rem; flex-wrap:wrap; }
    .choices { display:flex; flex-direction:column; gap:.6rem; margin: .6rem 0; position:relative; padding-bottom:120px; }
    .choice-row { display:flex; gap:.6rem; align-items:stretch; flex-wrap:nowrap; }
    .choice-row.single { flex-direction:row; justify-content:center; }
    .choice-row.two { justify-content:space-between; }
    .choice-row.vertical { flex-direction:column; align-items:stretch; }
    .choice-grid-2col { display:flex; gap:.6rem; flex-wrap:wrap; }
    .choices button {
      padding:1rem 1rem;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      white-space:normal;
      font-size:1.05rem;
      min-width:140px;
      min-height:56px;
      margin:4px 0;
      border-radius:10px;
      flex: 1 1 140px;
    }
    .correct { background: #d4ffd4 !important; }
    .wrong { background: #ffd6d6 !important; }
    .hidden { display:none; }
    audio { width:100%; margin: .8rem 0; }
    label { font-weight:600; margin-right:.4rem; }
    #loginBox { border:1px solid #ddd; padding:1rem; border-radius:6px; margin-bottom:1rem; background:#fafafa; }
    #controls { margin-bottom: 0.8rem; }
    .nav-grid { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .nav-item { width:46px; height:46px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; background:var(--nav-bg); cursor:default; user-select:none; font-weight:800; }
    .nav-item:hover { transform: translateY(-2px); }
    .nav-item.correct { background: var(--accent-green); color: white; box-shadow: 0 6px 14px rgba(33,196,106,0.18); cursor:pointer; }
    .nav-item.wrong { background: var(--accent-red); color: white; box-shadow: 0 6px 14px rgba(255, 71, 87,0.18); cursor:pointer; }
    .nav-item.current { outline:3px solid rgba(0,0,0,0.08); transform: translateY(-1px); }
    .nav-item.presented { color:#111; background: #f1f1f1; cursor:default; }
    .nav-item.not-presented { color:#999; background:#fbfbfb; cursor:default; }
    .nav-section { margin-top:10px; }
    .nav-section-title { font-weight:700; margin-top:8px; margin-bottom:6px; }
    .small { font-size:0.9rem; color:#555; }
    .user-buttons { display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.5rem; }
    .user-buttons button { padding:.5rem .8rem; font-weight:600; }
    .other-input { display:flex; gap:.5rem; align-items:center; margin-top:.5rem; }
    select, button, input { font:inherit; }
    #serverResponse { margin-left: 0.6rem; color: #333; font-size: 0.95rem; }
    #wrongStats { margin-top: 0.8rem; background:#fff8f0; padding:.6rem; border-radius:6px; border:1px solid #f0d7c0; white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; }
    #wrongStats .wrong-highlight { background:#ffd6d6; color:#900; padding:2px 6px; border-radius:4px; font-weight:700; }
    #submitInfo { margin-top: .6rem; font-weight:600; }
    .section-title { margin-top: 0.8rem; font-weight:700; }
    .review-section { margin-top: 12px; border-top:1px dashed #ddd; padding-top:8px; }
    .quiz-layout { display:flex; gap:1rem; align-items:flex-start; }
    .quiz-main { flex:1; min-width:0; position:relative; }
    .quiz-side { width:320px; flex-shrink:0; border-left:1px solid #eee; padding-left:16px; }
    @media (max-width:900px) {
      .quiz-layout { flex-direction:column; gap:.5rem; }
      .quiz-side { order: 0; width:100%; border-left:none; padding-left:0; padding-right:0; background:transparent; position:static; z-index:auto; border-bottom:none; margin-bottom:8px; }
      .quiz-main { order: 1; }
      .nav-grid { gap:6px; }
      .nav-item { width:40px; height:40px; font-size:.96rem; }
      .choices { padding-bottom:160px; }
    }

    .play-row { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:10px; }
    .play-left { display:flex; align-items:center; gap:12px; }
    #bigPlayBtn { width:96px; height:96px; border-radius:50%; background: linear-gradient(135deg,var(--accent-green),var(--accent-green-strong)); display:inline-flex; align-items:center; justify-content:center; box-shadow: 0 8px 22px rgba(39,174,96,0.22), inset 0 -5px 10px rgba(0,0,0,0.06); cursor:pointer; user-select:none; flex-shrink:0; }
    #bigPlayBtn svg { width:54px; height:54px; fill:white; }
    #playCounter { font-weight:700; color:#222; font-size:0.95rem; }
    #bigNextBtn { width:86px; height:86px; border-radius:50%; background: linear-gradient(135deg,#3498db,#2c82d6); display:inline-flex; align-items:center; justify-content:center; box-shadow: 0 8px 22px rgba(44,130,214,0.2), inset 0 -4px 8px rgba(0,0,0,0.06); cursor:pointer; user-select:none; flex-shrink:0; }
    #bigNextBtn svg { width:44px; height:44px; fill:white; }
    #copyToDocBtn { display:inline-flex; align-items:center; gap:10px; padding:12px 18px; border-radius:12px; background: linear-gradient(135deg,#6a11cb,#2575fc); color: white; font-weight:800; font-size:1rem; box-shadow: 0 10px 30px rgba(37,117,252,0.18); border: none; cursor: pointer; margin-top:10px; }
    #copyToDocBtn svg { width:20px; height:20px; fill: white; }
    #nextBtn { display:none; }

    /* celebration overlay */
    .celebration-overlay {
      position: fixed; left:0; right:0; top:0; bottom:0; display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:9999;
      background: rgba(0,0,0,0.28);
    }
    .celebration-center {
      position: relative;
      text-align:center;
      background: rgba(255,255,255,0.98);
      padding:20px 26px;
      border-radius:12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.16);
      font-weight:800;
      max-width:760px;
      z-index:10001;
    }
    .celebration-close {
      position:absolute; top:6px; right:10px; font-size:24px; background:#fff; border-radius:10px; width:64px; height:64px; border:1px solid rgba(0,0,0,0.08); cursor:pointer; z-index:10002;
      display:inline-flex; align-items:center; justify-content:center;
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
    }
    .celebration-timer {
      position:absolute; top:10px; left:12px; font-size:16px; color:#111; background:transparent; padding:6px 10px; border-radius:8px; z-index:10002;
      font-weight:700;
    }
    .celebration-burst {
      position:absolute; pointer-events:none; animation: floatUp 6000ms linear infinite;
      font-size:36px; z-index:10000;
    }
    @keyframes floatUp { 0% { transform: translateY(0) scale(0.8); opacity:0; } 10% { opacity:1; } 100% { transform: translateY(-420px) scale(1.05); opacity:0; } }
  </style>
</head>
<body>
  <h1>Music Ear Training for RCM Level 8 Exam (Sequence Mode)</h1>

  <div id="loginBox">
    <div><strong>Choose a user (no password required)</strong></div>
    <div class="user-buttons" style="margin-top:.6rem">
      <button id="btnBozart" type="button">Login as Bozart</button>
      <button id="btnTest" type="button">Login as Test</button>
    </div>

    <div class="other-input">
      <input id="otherName" placeholder="Other username (e.g. Alice)" />
      <button id="btnOther">Login as Other</button>
    </div>

    <div style="margin-top:.6rem">
      <button id="logoutBtn" class="hidden">Logout</button>
      <span id="loginMessage" style="margin-left:1rem;color:#444"></span>
      <span id="serverResponse"></span>
    </div>
  </div>

  <div id="controls" class="hidden">
    <div class="controls-row">
      <label>Mode:</label>
      <span class="small">Automatic sequence: Interval (N) → Chord (N) → Progressions (N each)</span>

      <label for="questionCount" style="margin-left:1rem">(Per-section count)</label>
      <input id="questionCount" type="number" min="1" value="5" style="width:5.2rem" />

      <button id="startBtn">Start Full Sequence</button>

      <div class="user-info" id="currentUserDisplay" style="margin-left:auto;font-weight:600"></div>
    </div>
    <div class="small">The quiz will present Interval questions first, then Chord, then multiple Progression sections. The directory on the right shows progress and will become clickable after you finish the full sequence.</div>
  </div>

  <p id="status" class="small"></p>

  <div id="quiz" class="hidden">
    <div class="quiz-layout">
      <div class="quiz-side" id="sideDirectory">
        <div><strong>Directory</strong></div>

        <div id="intervalSection" class="nav-section">
          <div class="nav-section-title">1. Interval Identification</div>
          <div id="intervalRow1" class="nav-grid"></div>
          <div id="intervalRow2" class="nav-grid" style="margin-top:6px"></div>
        </div>

        <div id="chordSection" class="nav-section">
          <div class="nav-section-title">2. Chord Identification</div>
          <div id="chordRow1" class="nav-grid"></div>
          <div id="chordRow2" class="nav-grid" style="margin-top:6px"></div>
        </div>

        <div id="progASection" class="nav-section">
          <div class="nav-section-title">3. Easy Progression A (Major)</div>
          <div id="progARow1" class="nav-grid"></div>
          <div id="progARow2" class="nav-grid" style="margin-top:6px"></div>
        </div>

        <div id="progBSection" class="nav-section">
          <div class="nav-section-title">4. Easy Progression B (minor)</div>
          <div id="progBRow1" class="nav-grid"></div>
          <div id="progBRow2" class="nav-grid" style="margin-top:6px"></div>
        </div>

        <div id="progCSection" class="nav-section">
          <div class="nav-section-title">5. Easy Progression C (Major & minor combo)</div>
          <div id="progCRow1" class="nav-grid"></div>
          <div id="progCRow2" class="nav-grid" style="margin-top:6px"></div>
        </div>

        <div id="progDSection" class="nav-section">
          <div class="nav-section-title">6. Easy Progression D (Major)</div>
          <div id="progDRow1" class="nav-grid"></div>
          <div id="progDRow2" class="nav-grid" style="margin-top:6px"></div>
        </div>

        <div id="progESection" class="nav-section">
          <div class="nav-section-title">7. Easy Progression E (minor)</div>
          <div id="progERow1" class="nav-grid"></div>
          <div id="progERow2" class="nav-grid" style="margin-top:6px"></div>
        </div>

        <div id="progFSection" class="nav-section">
          <div class="nav-section-title">8. Easy Progression F (Major & minor combo)</div>
          <div id="progFRow1" class="nav-grid"></div>
          <div id="progFRow2" class="nav-grid" style="margin-top:6px"></div>
        </div>

      </div>

      <div class="quiz-main">
        <div id="progress"></div>

        <audio id="player" preload="auto" controls></audio>

        <div class="play-row" id="playRow" style="display:none;">
          <div class="play-left">
            <div id="bigPlayBtn" title="Play / Pause (tap to play)">
              <svg id="bigPlayIcon" viewBox="0 0 64 64" aria-hidden="true">
                <path d="M16 12v40l36-20z"></path>
              </svg>
            </div>
            <div id="playCounter" class="small">Plays: 0</div>
          </div>

          <div>
            <div id="bigNextBtn" title="Next / Finish" style="display:none;">
              <svg id="bigNextIcon" viewBox="0 0 64 64" aria-hidden="true">
                <path d="M18 12v40l16-20zM34 12v40h12V12z"></path>
              </svg>
            </div>
          </div>
        </div>

        <div class="choices" id="choices"></div>

        <div style="margin-top:.6rem;">
          <div id="resultNotice" style="margin-left:auto"></div>
        </div>

        <p id="feedback"></p>
        <p id="score" class="hidden"></p>

        <div id="submitInfo" class="hidden"></div>

        <div id="wrongStats" class="hidden"></div>

        <div id="copyContainer" class="hidden">
          <button id="copyToDocBtn" type="button" title="Copy results & open teacher doc">
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M5 20h14v-2H5v2zm7-18l-5 5h3v4h4V7h3l-5-5z"/></svg>
            Copy results & Open Google Doc
          </button>
          <span class="small" style="margin-left:.6rem">This copies the results to clipboard and opens the teacher's Google Doc for pasting.</span>
        </div>

        <div id="reviewNav" style="margin-top:12px" class="hidden">
          <div><strong>Review</strong></div>
        </div>

        <div id="combinedReview" class="review-section hidden">
          <div class="section-title">All Quizzes Review</div>
          <div id="allReviewContainer"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="celebrationContainer" class="celebration-overlay" style="display:none" aria-hidden="true"></div>

  <script>
    // URLs and config
    const SHEET_WEBAPP_URL = "https://script.google.com/macros/s/AKfycbzS7uWPkIXHP94UG_7yrmLWL0VmArZgt084pgGgyzm2h-5Ad1PBOslSvXKQED_OOdd7HQ/exec";
    const TEACHER_DOC_URL = "https://docs.google.com/document/d/17P6DXWNvD-umI-M25iDnMJUewdUgNdkCDyruUeWgDts/edit?usp=sharing";

    // mapping and choices
    const codeToName = {
      "mi2":"minor 2nd","ma2":"Major 2nd","mi3":"minor 3rd","ma3":"Major 3rd",
      "p4":"Perfect 4th","a4":"Augmented 4th","p5":"Perfect 5th",
      "mi6":"minor 6th","ma6":"Major 6th","mi7":"minor 7th","ma7":"Major 7th",
      "ma":"Major Triad","mi":"minor Triad","a":"Augmented Triad","dom":"Dominant 7th","dim":"diminished 7th"
    };

    // PRE8 progression sections - exact keys match filename prefixes
    const PRE8_SECTIONS = {
      progA: { id: 'progA', title: 'Easy Progression A (Major)', rows: [['TST'], ['TDT'], ['TSD']], labels: {'TST':'I-IV-I / Major 1-4-1','TDT':'I-V-I / Major 1-5-1','TSD':'I-IV-V / Major 1-4-5'}, allowedPrefixes: ['TST','TDT','TSD'] },
      progB: { id: 'progB', title: 'Easy Progression B (minor)', rows: [['tst'], ['tDt'], ['tsD']], labels: {'tst':'i-iv-i / minor 1-4-1','tDt':'i-V-i / minor 1-5-1','tsD':'i-iv-V / minor 1-4-5'}, allowedPrefixes: ['tst','tDt','tsD'] },
      progC: { id: 'progC', title: 'Easy Progression C (Combo Major & minor)', rows: [['TST','tst'], ['TDT','tDt'], ['TSD','tsD']], labels: {'TST':'I-IV-I / Major 1-4-1','TDT':'I-V-I / Major 1-5-1','TSD':'I-IV-V / Major 1-4-5','tst':'i-iv-i / minor 1-4-1','tDt':'i-V-i / minor 1-5-1','tsD':'i-iv-V / minor 1-4-5'}, allowedPrefixes: ['TST','TDT','TSD','tst','tDt','tsD'] },
      progD: { id: 'progD', title: 'Easy Progression D (Major)', rows: [['SDT'], ['SDb'], ['bSD'], ['bST']], labels: {'SDT':'IV-V-I / Major 4-5-1','SDb':'IV-V-vi / Major 4-5-6','bSD':'vi-IV-V / Major 6-4-5','bST':'vi-IV-I / Major 6-4-1'}, allowedPrefixes: ['SDT','SDb','bSD','bST'] },
      progE: { id: 'progE', title: 'Easy Progression E (minor)', rows: [['sDt'], ['sDB'], ['BsD'], ['Bst']], labels: {'sDt':'iv-V-i / minor 4-5-1','sDB':'iv-V-VI / minor 4-5-6','BsD':'VI-iv-V / minor 6-4-5','Bst':'VI-iv-i / minor 6-4-1'}, allowedPrefixes: ['sDt','sDB','BsD','Bst'] },
      progF: { id: 'progF', title: 'Easy Progression F (Combo Major & minor)', rows: [['SDT','sDt'], ['SDb','sDB'], ['bSD','BsD'], ['bST','Bst']], labels: {'SDT':'IV-V-I / Major 4-5-1','SDb':'IV-V-vi / Major 4-5-6','bSD':'vi-IV-V / Major 6-4-5','bST':'vi-IV-I / Major 6-4-1','sDt':'iv-V-i / minor 4-5-1','sDB':'iv-V-VI / minor 4-5-6','BsD':'VI-iv-V / minor 6-4-5','Bst':'VI-iv-i / minor 6-4-1'}, allowedPrefixes: ['SDT','SDb','bSD','bST','sDt','sDB','BsD','Bst'] }
    };

    const INTERVAL_CHOICE_ROWS = [
      ["mi2", "ma2"],
      ["mi3", "ma3"],
      ["p4", "p5"],
      ["a4"],
      ["mi6", "ma6"],
      ["mi7", "ma7"]
    ];
    const CHORD_CHOICE_ROWS = [
      ["ma", "mi"],
      ["a"],
      ["dom", "dim"]
    ];

    const ACCOUNTS_KEY = "auralis_accounts_v1";
    const sessionResults = {};
    const lastQuestionsByType = {};

    // DOM refs
    const btnBozart = document.getElementById('btnBozart');
    const btnTest = document.getElementById('btnTest');
    const btnOther = document.getElementById('btnOther');
    const otherName = document.getElementById('otherName');
    const logoutBtn = document.getElementById('logoutBtn');
    const loginMessage = document.getElementById('loginMessage');
    const serverResponseEl = document.getElementById('serverResponse');
    const controls = document.getElementById('controls');
    const currentUserDisplay = document.getElementById('currentUserDisplay');
    const startBtn = document.getElementById('startBtn');
    const statusEl = document.getElementById('status');
    const questionCountInput = document.getElementById('questionCount');

    const choicesDiv = document.getElementById('choices');
    const player = document.getElementById('player');
    const bigPlayBtn = document.getElementById('bigPlayBtn');
    const bigPlayIcon = document.getElementById('bigPlayIcon');
    const playCounterEl = document.getElementById('playCounter');
    const playRow = document.getElementById('playRow');
    const bigNextBtn = document.getElementById('bigNextBtn');
    const progressEl = document.getElementById('progress');
    const feedback = document.getElementById('feedback');
    const scoreP = document.getElementById('score');
    const wrongStatsEl = document.getElementById('wrongStats');
    const submitInfo = document.getElementById('submitInfo');
    const copyContainer = document.getElementById('copyContainer');
    const copyToDocBtn = document.getElementById('copyToDocBtn');

    const intervalRow1 = document.getElementById('intervalRow1');
    const intervalRow2 = document.getElementById('intervalRow2');
    const chordRow1 = document.getElementById('chordRow1');
    const chordRow2 = document.getElementById('chordRow2');

    const progARow1 = document.getElementById('progARow1');
    const progARow2 = document.getElementById('progARow2');
    const progBRow1 = document.getElementById('progBRow1');
    const progBRow2 = document.getElementById('progBRow2');
    const progCRow1 = document.getElementById('progCRow1');
    const progCRow2 = document.getElementById('progCRow2');
    const progDRow1 = document.getElementById('progDRow1');
    const progDRow2 = document.getElementById('progDRow2');
    const progERow1 = document.getElementById('progERow1');
    const progERow2 = document.getElementById('progERow2');
    const progFRow1 = document.getElementById('progFRow1');
    const progFRow2 = document.getElementById('progFRow2');

    const reviewNav = document.getElementById('reviewNav');
    const combinedReview = document.getElementById('combinedReview');
    const allReviewContainer = document.getElementById('allReviewContainer');

    const celebrationContainer = document.getElementById('celebrationContainer');

    // helpers
    function loadAccounts(){ try{ return JSON.parse(localStorage.getItem(ACCOUNTS_KEY) || "{}"); }catch(e){return{}} }
    function saveAccounts(obj){ localStorage.setItem(ACCOUNTS_KEY, JSON.stringify(obj)); }

    (function ensureDemoAccounts(){
      const a = loadAccounts();
      if (!a["Bozart"]) a["Bozart"] = { results: [] };
      if (!a["Test"]) a["Test"] = { results: [] };
      saveAccounts(a);
    })();

    // login
    let currentUser = null;
    btnBozart.addEventListener('click', ()=> loginAs('Bozart'));
    btnTest.addEventListener('click', ()=> loginAs('Test'));
    btnOther.addEventListener('click', ()=> {
      const v = (otherName.value || "").trim();
      if (!v) { alert('Enter a username first'); return; }
      loginAs(v);
    });
    logoutBtn.addEventListener('click', ()=> {
      currentUser = null;
      loginMessage.textContent = "Logged out.";
      serverResponseEl.textContent = "";
      btnBozart.disabled = false; btnTest.disabled = false; btnOther.disabled = false; otherName.disabled = false;
      logoutBtn.classList.add('hidden');
      controls.classList.add('hidden');
      currentUserDisplay.textContent = "";
      document.getElementById('quiz').classList.add('hidden');
      for (const k of ['interval','chord','progA','progB','progC','progD','progE','progF']) {
        sessionResults[k] = null;
        lastQuestionsByType[k] = null;
      }
    });

    function loginAs(name){
      const accounts = loadAccounts();
      if (!accounts[name]) accounts[name] = { results: [] };
      saveAccounts(accounts);
      currentUser = name;
      loginMessage.textContent = `Logged in as ${name}.`;
      serverResponseEl.textContent = "";
      btnBozart.disabled = true; btnTest.disabled = true; btnOther.disabled = true; otherName.disabled = true;
      logoutBtn.classList.remove('hidden');
      controls.classList.remove('hidden');
      currentUserDisplay.textContent = `User: ${currentUser}`;
      if (filesLoadedByBranch['audio'] && filesLoadedByBranch['Chord'] && (filesLoadedByBranch['Progression-Pre8'] || filesLoadedByBranch['Progression'])) startBtn.disabled = false;
    }

    // file helpers
    function extractPrefixes(filename){
      const base = filename.split('/').pop();
      const raw = (base.split('_')[0] || "");
      const lower = raw.toLowerCase();
      return { raw, lower };
    }
    function jsDelivrUrlForBranch(branch, filename){
      return `https://cdn.jsdelivr.net/gh/dustmana8-byte/Auralis@${encodeURIComponent(branch)}/${encodeURIComponent(filename)}`;
    }
    function shuffle(a){ for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

    // load files
    const allFilesByBranch = {};
    const filesLoadedByBranch = {};
    async function loadFiles(branch){
      statusEl.textContent = `Loading audio files for branch "${branch}"...`;
      try{
        const api = `https://api.github.com/repos/dustmana8-byte/Auralis/contents?ref=${encodeURIComponent(branch)}`;
        const r = await fetch(api);
        if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
        const data = await r.json();
        const mp3s = data.filter(f => f.type === "file" && f.name.toLowerCase().endsWith('.mp3'));
        const files = mp3s.map(f => {
          const { raw, lower } = extractPrefixes(f.name);
          return { name: f.name, url: jsDelivrUrlForBranch(branch, f.name), rawKey: raw, rawKeyLower: lower, key: lower, displayName: f.name };
        }).filter(x => x.rawKey);
        if (files.length === 0) {
          statusEl.textContent = `No usable mp3 files found in branch ${branch}.`;
          filesLoadedByBranch[branch] = false;
          return;
        }
        allFilesByBranch[branch] = files;
        filesLoadedByBranch[branch] = true;
        statusEl.textContent = `Loaded ${files.length} audio files from branch "${branch}".`;
        if (currentUser && filesLoadedByBranch['audio'] && filesLoadedByBranch['Chord'] && (filesLoadedByBranch['Progression-Pre8'] || filesLoadedByBranch['Progression'])) startBtn.disabled = false;
      } catch(err){
        statusEl.textContent = "Failed to load audio files: " + err.message;
        console.error(err);
        filesLoadedByBranch[branch] = false;
      }
    }

    (async function init(){
      startBtn.disabled = true;
      await loadFiles('audio');
      loadFiles('Chord').catch(()=>{});
      loadFiles('Progression-Pre8').catch(()=>{});
      loadFiles('Progression').catch(()=>{});
    })();

    // preload
    const audioContext = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;
    const preloadedMap = new Map();
    async function ensureBuffered(url){
      if (preloadedMap.has(url)) return preloadedMap.get(url);
      try {
        const resp = await fetch(url, {mode: 'cors'});
        if (!resp.ok) throw new Error('fetch failed ' + resp.status);
        const arrayBuffer = await resp.arrayBuffer();
        if (audioContext && audioContext.state !== 'suspended') {
          audioContext.decodeAudioData(arrayBuffer.slice(0), ()=>{}, ()=>{});
        }
        const blob = new Blob([arrayBuffer], { type: 'audio/mpeg' });
        const objectUrl = URL.createObjectURL(blob);
        preloadedMap.set(url, objectUrl);
        return objectUrl;
      } catch(err) {
        console.warn('Preload failed, fallback to original URL', err);
        return url;
      }
    }

    // quiz state
    let questions = [], currentIdx = 0, presentedCount = 0, quizFinished = false;

    // build questions with correctKey normalized where needed
    function buildCombinedQuestions(perSectionCount){
      questions = [];
      function pickFromBranch(branch, count, sectionName, allowedPrefixes = null, keyMode = 'raw'){
        let pool = (allFilesByBranch[branch] || []).slice();
        if (allowedPrefixes && allowedPrefixes.length){
          // prefer exact-case matches first
          let filtered = pool.filter(f => allowedPrefixes.includes(f.rawKey));
          if (filtered.length === 0) {
            const low = allowedPrefixes.map(p=>p.toLowerCase());
            filtered = pool.filter(f => low.includes(f.rawKeyLower));
          }
          pool = filtered.slice();
        }
        pool = shuffle(pool);
        if (pool.length === 0) pool = shuffle((allFilesByBranch[branch] || []).slice());
        for (let i=0;i<count;i++){
          if (pool.length===0) break;
          const file = pool.pop();
          let correctKey;
          if (keyMode === 'lower') correctKey = file.rawKeyLower;
          else correctKey = file.rawKey;
          const idxInSection = i + 1;
          questions.push({ section: sectionName, file, correctKey, selectedKey: null, playCount: 0, _answered: false, indexInSection: idxInSection });
        }
      }

      // interval: use 'audio' branch and normalized lower-case keys (so they match choice keys like 'ma2')
      pickFromBranch('audio', perSectionCount, 'interval', null, 'lower');
      // chord: use 'Chord' branch and lower-case keys
      pickFromBranch('Chord', perSectionCount, 'chord', null, 'lower');

      const progBranch = (allFilesByBranch['Progression-Pre8'] ? 'Progression-Pre8' : 'Progression');
      // progression parts: use PRE8_SECTIONS allowedPrefixes; keyMode raw to preserve case-sensitive prefixes used in PRE8_SECTIONS
      Object.keys(PRE8_SECTIONS).forEach(secKey=>{
        const sec = PRE8_SECTIONS[secKey];
        pickFromBranch(progBranch, perSectionCount, secKey, sec.allowedPrefixes, 'raw');
      });

      // Assign overall sequence index for each question so results can reference exact sequence positions
      questions.forEach((q, i) => { q.overallIndex = i + 1; });
    }

    startBtn.addEventListener('click', ()=>{
      if (!currentUser) { alert("Please login first"); return; }
      const perSectionCount = Math.max(1, parseInt(questionCountInput.value,10) || 5);
      if (!filesLoadedByBranch['audio'] || !filesLoadedByBranch['Chord'] || !(filesLoadedByBranch['Progression-Pre8'] || filesLoadedByBranch['Progression'])) {
        alert('Audio files for all branches are not ready yet. Please wait a moment for loading to finish.');
        return;
      }
      buildCombinedQuestions(perSectionCount);
      currentIdx = 0;
      presentedCount = 1;
      quizFinished = false;
      document.getElementById('quiz').classList.remove('hidden');
      scoreP.classList.add('hidden');
      reviewNav.classList.remove('hidden');
      wrongStatsEl.classList.remove('hidden');
      submitInfo.classList.add('hidden');
      copyContainer.classList.add('hidden');
      combinedReview.classList.add('hidden');

      populateSequenceNav(perSectionCount);

      playRow.style.display = 'flex';
      document.getElementById('bigNextBtn').style.display = 'none';

      ensureBuffered(questions[0].file.url).then(objUrl => {
        player.src = objUrl || questions[0].file.url;
        player.load();
      }).catch(()=>{ player.src = questions[0].file.url; player.load(); });

      renderQuestion(currentIdx, false);
      updateNavPresentation();
    });

    function populateSequenceNav(perSectionCount){
      [intervalRow1, intervalRow2, chordRow1, chordRow2,
       progARow1, progARow2, progBRow1, progBRow2,
       progCRow1, progCRow2, progDRow1, progDRow2,
       progERow1, progERow2, progFRow1, progFRow2].forEach(r => r.innerHTML = '');

      function makeEl(label, idx){
        const d = document.createElement('div');
        d.className = 'nav-item not-presented';
        d.textContent = label;
        d.dataset.index = idx;
        return d;
      }

      const counts = {};
      counts.interval = questions.filter(q=>q.section==='interval').length;
      counts.chord = questions.filter(q=>q.section==='chord').length;
      counts.progA = questions.filter(q=>q.section==='progA').length;
      counts.progB = questions.filter(q=>q.section==='progB').length;
      counts.progC = questions.filter(q=>q.section==='progC').length;
      counts.progD = questions.filter(q=>q.section==='progD').length;
      counts.progE = questions.filter(q=>q.section==='progE').length;
      counts.progF = questions.filter(q=>q.section==='progF').length;

      let idx = 0;
      for (let i=0;i<counts.interval;i++){
        const label = `1.${i+1}`;
        const el = makeEl(label, idx++);
        if (i < Math.ceil(counts.interval/2)) intervalRow1.appendChild(el); else intervalRow2.appendChild(el);
      }
      for (let i=0;i<counts.chord;i++){
        const label = `2.${i+1}`;
        const el = makeEl(label, idx++);
        if (i < Math.ceil(counts.chord/2)) chordRow1.appendChild(el); else chordRow2.appendChild(el);
      }
      for (let i=0;i<counts.progA;i++){
        const label = `3.${i+1}`;
        const el = makeEl(label, idx++);
        if (i < Math.ceil(counts.progA/2)) progARow1.appendChild(el); else progARow2.appendChild(el);
      }
      for (let i=0;i<counts.progB;i++){
        const label = `4.${i+1}`;
        const el = makeEl(label, idx++);
        if (i < Math.ceil(counts.progB/2)) progBRow1.appendChild(el); else progBRow2.appendChild(el);
      }
      for (let i=0;i<counts.progC;i++){
        const label = `5.${i+1}`;
        const el = makeEl(label, idx++);
        if (i < Math.ceil(counts.progC/2)) progCRow1.appendChild(el); else progCRow2.appendChild(el);
      }
      for (let i=0;i<counts.progD;i++){
        const label = `6.${i+1}`;
        const el = makeEl(label, idx++);
        if (i < Math.ceil(counts.progD/2)) progDRow1.appendChild(el); else progDRow2.appendChild(el);
      }
      for (let i=0;i<counts.progE;i++){
        const label = `7.${i+1}`;
        const el = makeEl(label, idx++);
        if (i < Math.ceil(counts.progE/2)) progERow1.appendChild(el); else progERow2.appendChild(el);
      }
      for (let i=0;i<counts.progF;i++){
        const label = `8.${i+1}`;
        const el = makeEl(label, idx++);
        if (i < Math.ceil(counts.progF/2)) progFRow1.appendChild(el); else progFRow2.appendChild(el);
      }

      updateNavPresentation();
    }

    function updateNavPresentation(){
      const containers = [intervalRow1, intervalRow2, chordRow1, chordRow2,
                          progARow1, progARow2, progBRow1, progBRow2,
                          progCRow1, progCRow2, progDRow1, progDRow2,
                          progERow1, progERow2, progFRow1, progFRow2];
      containers.forEach(container=>{
        Array.from(container.children).forEach(node=>{
          const idx = parseInt(node.dataset.index,10);
          node.classList.remove('presented','not-presented','current','correct','wrong');
          const q = questions[idx];
          if (quizFinished){
            if (!q || !q.selectedKey) {
              node.classList.add('not-presented');
              node.style.cursor = 'default';
            } else {
              if (q.selectedKey === q.correctKey) { node.classList.add('correct'); node.style.cursor='pointer'; }
              else { node.classList.add('wrong'); node.style.cursor='pointer'; }
            }
          } else {
            if (idx < presentedCount) { node.classList.add('presented'); node.style.cursor='default'; } else { node.classList.add('not-presented'); node.style.cursor='default'; }
          }
        });
      });
      updateNavHighlight();
    }
    function updateNavHighlight(){
      [intervalRow1, intervalRow2, chordRow1, chordRow2,
       progARow1, progARow2, progBRow1, progBRow2,
       progCRow1, progCRow2, progDRow1, progDRow2,
       progERow1, progERow2, progFRow1, progFRow2].forEach(container=>Array.from(container.children).forEach(n=>n.classList.remove('current')));
      const cur = document.querySelector(`[data-index="${currentIdx}"]`);
      if (cur) cur.classList.add('current');
    }

    function updatePlayCounter(){
      const q = questions[currentIdx];
      playCounterEl.textContent = `Plays: ${q ? (q.playCount || 0) : 0}`;
    }

    function showTopNext(){ document.getElementById('bigNextBtn').style.display = 'inline-flex'; }
    function hideTopNext(){ document.getElementById('bigNextBtn').style.display = 'none'; }

    // Create a choice button
    function makeChoiceButton(key, label){
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.textContent = label;
      btn.dataset.key = key;
      return btn;
    }

    // render question
    async function renderQuestion(idx, reviewing=false){
      const q = questions[idx];
      const sameBefore = questions.slice(0, idx).filter(x=>x.section===q.section).length;
      const sectionPos = sameBefore + 1;
      const sectionTotal = questions.filter(x=>x.section===q.section).length;
      const sectionLabel = (q.section === 'interval') ? 'Interval' : (q.section === 'chord') ? 'Chord' :
        (q.section === 'progA') ? 'Easy Progression A' :
        (q.section === 'progB') ? 'Easy Progression B' :
        (q.section === 'progC') ? 'Easy Progression C' :
        (q.section === 'progD') ? 'Easy Progression D' :
        (q.section === 'progE') ? 'Easy Progression E' :
        (q.section === 'progF') ? 'Easy Progression F' : q.section;

      progressEl.textContent = `${sectionLabel.toUpperCase()} Question ${sectionPos} / ${sectionTotal}  (Overall ${idx+1} / ${questions.length})`;
      feedback.textContent = "";
      choicesDiv.innerHTML = "";
      hideTopNext();

      playRow.style.display = 'flex';

      try {
        const objUrl = await ensureBuffered(q.file.url);
        player.src = objUrl || q.file.url;
        player.load();
      } catch(e){
        player.src = q.file.url;
        player.load();
      }

      const next = questions[idx+1];
      if (next) ensureBuffered(next.file.url).catch(()=>{});

      updatePlayCounter();

      if (q.section.startsWith('prog')) {
        const s = PRE8_SECTIONS[q.section];
        s.rows.forEach(row=>{
          let rowDiv;
          if (row.length === 1) rowDiv = document.createElement('div'), rowDiv.className = 'choice-row vertical';
          else if (row.length === 2) rowDiv = document.createElement('div'), rowDiv.className = 'choice-row two';
          else rowDiv = document.createElement('div'), rowDiv.className = 'choice-row';
          row.forEach(k=>{
            const key = k;
            const label = s.labels[key] || key;
            const btn = makeChoiceButton(key, label);
            if (reviewing || q.selectedKey !== null || quizFinished){
              btn.disabled = true;
              if (quizFinished){
                if (key === q.correctKey) btn.classList.add('correct');
                if (q.selectedKey && key === q.selectedKey && q.selectedKey !== q.correctKey) btn.classList.add('wrong');
              } else {
                if (key === q.correctKey) btn.classList.add('correct');
              }
            } else {
              btn.addEventListener('click', ()=>{
                q.selectedKey = key;
                q._answered = true;
                if (key === q.correctKey) btn.classList.add('correct'); else btn.classList.add('wrong');
                Array.from(rowDiv.parentElement.querySelectorAll('button')).forEach(b=>{
                  b.disabled = true;
                  if (b.dataset.key === q.correctKey) b.classList.add('correct');
                });
                showTopNext();
              });
            }
            rowDiv.appendChild(btn);
          });
          choicesDiv.appendChild(rowDiv);
        });
      } else if (q.section === 'chord') {
        CHORD_CHOICE_ROWS.forEach(row=>{
          const rowDiv = document.createElement('div'); rowDiv.className = (row.length===1) ? 'choice-row single' : 'choice-row two';
          row.forEach(k=>{
            const btn = makeChoiceButton(k, codeToName[k] || k);
            if (reviewing || q.selectedKey !== null || quizFinished){
              btn.disabled = true;
              if (quizFinished){
                if (k === q.correctKey) btn.classList.add('correct');
                if (q.selectedKey && k === q.selectedKey && q.selectedKey !== q.correctKey) btn.classList.add('wrong');
              } else {
                if (k === q.correctKey) btn.classList.add('correct');
              }
            } else {
              btn.addEventListener('click', ()=>{
                q.selectedKey = k;
                q._answered = true;
                if (k === q.correctKey) btn.classList.add('correct'); else btn.classList.add('wrong');
                Array.from(rowDiv.parentElement.querySelectorAll('button')).forEach(b=>{
                  b.disabled = true;
                  if (b.dataset.key === q.correctKey) b.classList.add('correct');
                });
                showTopNext();
              });
            }
            rowDiv.appendChild(btn);
          });
          choicesDiv.appendChild(rowDiv);
        });
      } else { // interval
        INTERVAL_CHOICE_ROWS.forEach(row=>{
          const rowDiv = document.createElement('div'); rowDiv.className = (row.length===1) ? 'choice-row single' : 'choice-row two';
          row.forEach(k=>{
            const btn = makeChoiceButton(k, codeToName[k] || k);
            if (reviewing || q.selectedKey !== null || quizFinished){
              btn.disabled = true;
              if (quizFinished){
                if (k === q.correctKey) btn.classList.add('correct');
                if (q.selectedKey && k === q.selectedKey && q.selectedKey !== q.correctKey) btn.classList.add('wrong');
              } else {
                if (k === q.correctKey) btn.classList.add('correct');
              }
            } else {
              btn.addEventListener('click', ()=>{
                q.selectedKey = k;
                q._answered = true;
                if (k === q.correctKey) btn.classList.add('correct'); else btn.classList.add('wrong');
                Array.from(rowDiv.parentElement.querySelectorAll('button')).forEach(b=>{
                  b.disabled = true;
                  if (b.dataset.key === q.correctKey) b.classList.add('correct');
                });
                showTopNext();
              });
            }
            rowDiv.appendChild(btn);
          });
          choicesDiv.appendChild(rowDiv);
        });
      }

      if (idx >= presentedCount) presentedCount = idx + 1;
      updateNavPresentation();
      updateNavHighlight();

      if (!reviewing) {
        try { await player.play().catch(()=>{}); } catch(e){ }
      }
    }

    // audio events
    player.addEventListener('play', ()=>{
      const q = questions[currentIdx];
      if (!q) return;
      if (!quizFinished && !q._answered) {
        q.playCount = (q.playCount || 0) + 1;
        updatePlayCounter();
      }
      bigPlayIcon.innerHTML = '<path d="M20 12h8v40h-8zM36 12h8v40h-8z"></path>';
    });
    player.addEventListener('pause', ()=> { bigPlayIcon.innerHTML = '<path d="M16 12v40l36-20z"></path>'; });
    player.addEventListener('ended', ()=> { bigPlayIcon.innerHTML = '<path d="M16 12v40l36-20z"></path>'; });

    bigPlayBtn.addEventListener('click', async ()=>{
      try { if (player.paused) await player.play(); else player.pause(); } catch(err){ alert('Playback failed: ' + (err && err.message ? err.message : err)); }
    });

    async function handleTopNext(){
      document.getElementById('bigNextBtn').style.display = 'none';
      if (currentIdx >= questions.length - 1) { await finalizeCombinedQuiz(); return; }
      currentIdx++;
      const q = questions[currentIdx];
      ensureBuffered(q.file.url).then(objUrl=>{
        player.src = objUrl || q.file.url;
        player.load();
      }).catch(()=>{ player.src = q.file.url; player.load(); });
      renderQuestion(currentIdx, false);
    }
    bigNextBtn.addEventListener('click', handleTopNext);

    // Edmonton timestamp
    function getEdmontonTimestamp(){
      try {
        const opts = { timeZone: 'America/Edmonton', year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false };
        const parts = new Intl.DateTimeFormat('en-CA', opts).formatToParts(new Date());
        const map = {};
        parts.forEach(p => { if (p.type !== 'literal') map[p.type] = p.value; });
        const tz = 'MT';
        return `${map.year}-${map.month}-${map.day} ${map.hour}:${map.minute}:${map.second} ${tz}`;
      } catch(e){
        return new Date().toISOString();
      }
    }

    // finalize and improved results formatting (now includes overall sequence indexes and a wrong-summary per Part)
    async function finalizeCombinedQuiz(){
      quizFinished = true;
      const sections = {
        interval: { score:0, total:0, questionDetails:[], wrongCounts:{} },
        chord: { score:0, total:0, questionDetails:[], wrongCounts:{} },
        progA: { score:0, total:0, questionDetails:[], wrongCounts:{} },
        progB: { score:0, total:0, questionDetails:[], wrongCounts:{} },
        progC: { score:0, total:0, questionDetails:[], wrongCounts:{} },
        progD: { score:0, total:0, questionDetails:[], wrongCounts:{} },
        progE: { score:0, total:0, questionDetails:[], wrongCounts:{} },
        progF: { score:0, total:0, questionDetails:[], wrongCounts:{} }
      };

      // Use questions with knowledge of overallIndex
      questions.forEach((q, overallIdx)=>{
        const sec = sections[q.section];
        if (!sec) return;
        sec.total++;
        if (q.selectedKey === q.correctKey) sec.score++;
        else sec.wrongCounts[q.correctKey] = (sec.wrongCounts[q.correctKey] || 0) + 1;
        sec.questionDetails.push({
          correctKey: q.correctKey,
          selectedKey: q.selectedKey || null,
          fileName: q.file.name,
          playCount: q.playCount || 0,
          indexInSection: q.indexInSection || null,
          overallIndex: q.overallIndex || (overallIdx+1)
        });
      });

      const timestamp = getEdmontonTimestamp();

      const accounts = loadAccounts();
      if (!accounts[currentUser]) accounts[currentUser] = { results: [] };

      Object.keys(sections).forEach(secKey=>{
        const sec = sections[secKey];
        const record = { quizType: secKey, score: sec.score, total: sec.total, date: timestamp, questionDetails: sec.questionDetails, wrongCounts: sec.wrongCounts };
        accounts[currentUser].results.push(record);
        sessionResults[secKey] = record;
        lastQuestionsByType[secKey] = questions.filter(q=>q.section===secKey).map(q=>({ ...q }));
        sendResultToSheet({
          uid: currentUser,
          email: currentUser + "@example.com",
          quizType: secKey,
          score: sec.score,
          total: sec.total,
          wrongCounts: sec.wrongCounts,
          questionDetails: sec.questionDetails,
          date: timestamp
        }).then(ok => {
          if (ok) serverResponseEl.textContent = "Sheet: saved ✓";
          else serverResponseEl.textContent = "Sheet: failed to save";
        });
      });

      saveAccounts(accounts);

      const totalCorrect = Object.values(sections).reduce((s,sec)=>s+sec.score,0);
      const totalQuestions = Object.values(sections).reduce((s,sec)=>s+sec.total,0);
      scoreP.textContent = `Combined score: ${totalCorrect} / ${totalQuestions} (${Math.round(1000*totalCorrect/totalQuestions)/10}%).`;
      scoreP.classList.remove('hidden');

      submitInfo.textContent = `Submitted by: ${currentUser}  —  Time: ${timestamp}  — Full sequence`;
      submitInfo.classList.remove('hidden');

      // Build improved Correct/Wrong summary with HTML and wrong summary using overall sequence numbers
      let outHtml = '';
      Object.keys(sections).forEach((secKey)=>{
        const sec = sections[secKey];
        const secTitle = (secKey === 'interval') ? 'Part 1: Interval Identification' : (secKey === 'chord') ? 'Part 2: Chord Identification' :
                         (secKey === 'progA') ? 'Part 3: Easy Progression A (Major)' :
                         (secKey === 'progB') ? 'Part 4: Easy Progression B (minor)' :
                         (secKey === 'progC') ? 'Part 5: Easy Progression C (Combo)' :
                         (secKey === 'progD') ? 'Part 6: Easy Progression D (Major)' :
                         (secKey === 'progE') ? 'Part 7: Easy Progression E (minor)' :
                         (secKey === 'progF') ? 'Part 8: Easy Progression F (Combo)' : secKey;

        outHtml += `<div><strong>${secTitle} — Score: ${sec.score} / ${sec.total}</strong></div>`;
        outHtml += `<div style="margin-top:6px"><strong>Question Details:</strong></div>`;
        // Question details list (one per question in this section)
        outHtml += `<div style="white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', monospace; margin-left:6px;">`;
        sec.questionDetails.forEach(qd=>{
          const qnSec = qd.indexInSection || '?';
          const qnOverall = qd.overallIndex || '?';
          let correctLabel = labelForKey(secKey, qd.correctKey);
          let selectedLabel = qd.selectedKey ? labelForKey(secKey, qd.selectedKey) : '(no answer)';
          // mark wrong lines visually
          if (qd.selectedKey && qd.selectedKey !== qd.correctKey) {
            outHtml += `Overall Q${qnOverall} (Sec Q${qnSec}): Correct: ${correctLabel}  — Selected: <span class="wrong-highlight">${selectedLabel}</span>  — Plays: ${qd.playCount || 0}  — (${qd.fileName})\n`;
          } else if (!qd.selectedKey) {
            outHtml += `Overall Q${qnOverall} (Sec Q${qnSec}): Correct: ${correctLabel}  — Selected: (no answer)  — Plays: ${qd.playCount || 0}  — (${qd.fileName})\n`;
          } else {
            outHtml += `Overall Q${qnOverall} (Sec Q${qnSec}): Correct: ${correctLabel}  — Selected: ${selectedLabel}  — Plays: ${qd.playCount || 0}  — (${qd.fileName})\n`;
          }
        });
        outHtml += `</div>`;

        // After details, produce wrong summary (using overall sequence numbers)
        const wrongOverallNums = sec.questionDetails.filter(qd => qd.selectedKey && qd.selectedKey !== qd.correctKey).map(qd => qd.overallIndex);
        const wrongSummary = wrongOverallNums.length ? wrongOverallNums.join(', ') : '(none)';
        outHtml += `<div style="margin-top:6px;"><strong>Wrong (overall sequence numbers):</strong> ${wrongSummary}</div>`;

        outHtml += `<hr style="margin:12px 0; border:none; border-top:1px dashed #ddd;">`;
      });

      wrongStatsEl.innerHTML = outHtml;
      wrongStatsEl.classList.remove('hidden');

      makeDirectoryInteractiveAndColor();
      copyContainer.classList.remove('hidden');
      copyToDocBtn.onclick = async ()=> { await copyResultsAndOpenDocCombined(TEACHER_DOC_URL); };
      combinedReview.classList.remove('hidden');
      populateCombinedReview();

      // celebration
      const perfectParts = [];
      Object.keys(sections).forEach((k)=>{
        const s = sections[k];
        if (s.total>0 && s.score === s.total) {
          const partNum = (k === 'interval') ? 1 : (k === 'chord') ? 2 :
                          (k === 'progA') ? 3 :
                          (k === 'progB') ? 4 :
                          (k === 'progC') ? 5 :
                          (k === 'progD') ? 6 :
                          (k === 'progE') ? 7 :
                          (k === 'progF') ? 8 : null;
          if (partNum) perfectParts.push(partNum);
        }
      });

      if (perfectParts.length > 0) {
        if (perfectParts.length === 8) showCelebration(perfectParts, true);
        else showCelebration(perfectParts, false);
      }

      hideTopNext();
    }

    // helper label conversion
    function labelForKey(sectionKey, key){
      if (!key) return "(no answer)";
      if (sectionKey === 'interval' || sectionKey === 'chord') {
        // keys stored lower-case like 'ma2' or 'ma'
        return codeToName[key] || key;
      } else if (sectionKey.startsWith('prog')) {
        const map = PRE8_SECTIONS[sectionKey];
        return (map && map.labels && map.labels[key]) ? map.labels[key] : key;
      }
      return key;
    }

    function makeDirectoryInteractiveAndColor(){
      const containers = [intervalRow1, intervalRow2, chordRow1, chordRow2,
                          progARow1, progARow2, progBRow1, progBRow2,
                          progCRow1, progCRow2, progDRow1, progDRow2,
                          progERow1, progERow2, progFRow1, progFRow2];
      containers.forEach(container=>{
        Array.from(container.children).forEach(node=>{
          const idx = parseInt(node.dataset.index,10);
          const q = questions[idx];
          const newNode = node.cloneNode(true);
          node.parentNode.replaceChild(newNode, node);
          newNode.classList.remove('presented','not-presented','current','correct','wrong');
          if (!q || !q.selectedKey) {
            newNode.classList.add('not-presented');
            newNode.style.cursor = 'default';
            return;
          }
          if (q.selectedKey === q.correctKey) newNode.classList.add('correct'); else newNode.classList.add('wrong');
          newNode.style.cursor = 'pointer';
          newNode.addEventListener('click', ()=>{
            renderQuestion(idx, true);
            currentIdx = idx;
            updateNavHighlight();
          });
        });
      });
    }

    function populateCombinedReview(){
      allReviewContainer.innerHTML = "";
      const sectionsMeta = [
        { key: 'interval', title: 'Interval Identification' },
        { key: 'chord', title: 'Chord Identification' },
        { key: 'progA', title: 'Easy Progression A (Major)' },
        { key: 'progB', title: 'Easy Progression B (minor)' },
        { key: 'progC', title: 'Easy Progression C (Combo)' },
        { key: 'progD', title: 'Easy Progression D (Major)' },
        { key: 'progE', title: 'Easy Progression E (minor)' },
        { key: 'progF', title: 'Easy Progression F (Combo)' }
      ];
      sectionsMeta.forEach(section=>{
        const res = sessionResults[section.key];
        const sectionDiv = document.createElement('div');
        sectionDiv.className = 'review-section';
        const h = document.createElement('div');
        h.className = 'section-title';
        const scoreText = res ? ` — Score: ${res.score} / ${res.total}` : '';
        h.textContent = section.title + scoreText;
        sectionDiv.appendChild(h);
        if (!res) {
          const p = document.createElement('div'); p.className='small'; p.textContent='Not taken in this session.'; sectionDiv.appendChild(p); allReviewContainer.appendChild(sectionDiv); return;
        }

        const pre = document.createElement('pre');
        pre.style.whiteSpace = 'pre-wrap';
        pre.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace';

        let text = '';
        res.questionDetails.forEach((qd)=>{
          const qnSec = qd.indexInSection || '?';
          const qnOverall = qd.overallIndex || '?';
          let corr = qd.correctKey;
          let sel = qd.selectedKey || "(no answer)";
          if (section.key.startsWith('prog')) {
            const mapping = PRE8_SECTIONS[section.key];
            if (mapping) {
              corr = mapping.labels[qd.correctKey] || qd.correctKey;
              sel = qd.selectedKey ? (mapping.labels[qd.selectedKey] || qd.selectedKey) : "(no answer)";
            }
          } else {
            corr = codeToName[qd.correctKey] || qd.correctKey;
            sel = qd.selectedKey ? (codeToName[qd.selectedKey] || qd.selectedKey) : "(no answer)";
          }
          if (qd.selectedKey && qd.selectedKey !== qd.correctKey) {
            text += `Overall Q${qnOverall} (Sec Q${qnSec}): Correct: ${corr}  — Selected: ${sel}  — Plays: ${qd.playCount || 0}  (${qd.fileName})\n`;
          } else {
            text += `Overall Q${qnOverall} (Sec Q${qnSec}): Correct: ${corr}  — Selected: ${sel}  — Plays: ${qd.playCount || 0}  (${qd.fileName})\n`;
          }
        });

        // wrong summary
        const wrongOverallNums = res.questionDetails.filter(qd => qd.selectedKey && qd.selectedKey !== qd.correctKey).map(qd => qd.overallIndex);
        const wrongSummary = wrongOverallNums.length ? wrongOverallNums.join(', ') : '(none)';
        text += `\nWrong (overall sequence numbers): ${wrongSummary}\n`;

        pre.textContent = text;
        sectionDiv.appendChild(pre);
        allReviewContainer.appendChild(sectionDiv);
      });
    }

    async function sendResultToSheet(data){
      try {
        const res = await fetch(SHEET_WEBAPP_URL, {
          method:'POST',
          headers:{ 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        if (!res.ok) {
          console.error('Sheet POST failed', res.status, await res.text());
          return false;
        }
        const j = await res.json().catch(()=>null);
        if (j && j.ok === false) return false;
        return true;
      } catch(err){ console.error('Error sending to sheet:', err); return false; }
    }

    // copy combined results and open teacher doc — now includes Wrong summary per Part (overall sequence numbers)
    async function copyResultsAndOpenDocCombined(docUrl){
      let text = "";
      text += "Auralis Combined Quiz Results\n";
      text += "-----------------------------\n";
      text += `User: ${currentUser}\n`;
      text += `Time: ${getEdmontonTimestamp()}\n\n`;
      const sectionsOrder = ['interval','chord','progA','progB','progC','progD','progE','progF'];
      sectionsOrder.forEach(secKey=>{
        const res = sessionResults[secKey];
        if (!res) return;
        const title = (secKey === 'interval') ? 'Part 1: Interval Identification' :
                      (secKey === 'chord') ? 'Part 2: Chord Identification' :
                      (secKey === 'progA') ? 'Part 3: Easy Progression A (Major)' :
                      (secKey === 'progB') ? 'Part 4: Easy Progression B (minor)' :
                      (secKey === 'progC') ? 'Part 5: Easy Progression C (Combo)' :
                      (secKey === 'progD') ? 'Part 6: Easy Progression D (Major)' :
                      (secKey === 'progE') ? 'Part 7: Easy Progression E (minor)' :
                      (secKey === 'progF') ? 'Part 8: Easy Progression F (Combo)' : secKey;
        text += `${title}: ${res.score} / ${res.total}\n`;
        res.questionDetails.forEach(qd=>{
          let corr = qd.correctKey;
          let sel = qd.selectedKey || "(no answer)";
          if (secKey.startsWith('prog')) {
            const map = PRE8_SECTIONS[secKey];
            if (map) {
              corr = map.labels[qd.correctKey] || qd.correctKey;
              sel = qd.selectedKey ? (map.labels[qd.selectedKey] || qd.selectedKey) : "(no answer)";
            }
          } else {
            corr = codeToName[qd.correctKey] || qd.correctKey;
            sel = qd.selectedKey ? (codeToName[qd.selectedKey] || qd.selectedKey) : "(no answer)";
          }
          const qn = qd.overallIndex || qd.indexInSection || '';
          text += `Q${qn}: ${qd.fileName} — Correct: ${corr} — Selected: ${sel} — Plays: ${qd.playCount || 0}\n`;
        });
        // append wrong summary for this section (overall sequence numbers)
        const wrongOverallNums = res.questionDetails.filter(qd => qd.selectedKey && qd.selectedKey !== qd.correctKey).map(qd => qd.overallIndex);
        const wrongSummary = wrongOverallNums.length ? wrongOverallNums.join(', ') : '(none)';
        text += `Wrong (overall sequence numbers): ${wrongSummary}\n\n`;
      });

      try {
        await navigator.clipboard.writeText(text);
        window.open(docUrl, '_blank');
      } catch(e){
        alert('Copy failed: ' + (e && e.message ? e.message : e));
      }
    }

    // Celebration UI (persistent until user closes).  Added robust close and 15s countdown.
    let _celebrationInterval = null;
    let _celebrationTimeout = null;

    function playSuccessSound(short=true){
      try {
        if (!audioContext) return;
        const ctx = audioContext;
        const now = ctx.currentTime;
        if (short) {
          const freqs = [880, 1046.5, 1318.5];
          freqs.forEach((f,i)=>{
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            o.type = 'sine';
            o.frequency.value = f;
            g.gain.value = 0;
            o.connect(g);
            g.connect(ctx.destination);
            o.start(now + i*0.06);
            g.gain.linearRampToValueAtTime(0.12, now + i*0.06 + 0.01);
            g.gain.linearRampToValueAtTime(0.0, now + i*0.06 + 0.5);
            o.stop(now + i*0.06 + 0.55);
          });
        } else {
          const bufferSize = ctx.sampleRate * 1.6;
          const buff = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
          const data = buff.getChannelData(0);
          for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * Math.exp(-i/(bufferSize/1.0));
          const src = ctx.createBufferSource();
          src.buffer = buff;
          const g = ctx.createGain(); g.gain.value = 0.6;
          src.connect(g); g.connect(ctx.destination);
          src.start(now);
          src.stop(now + 1.6);
          const o = ctx.createOscillator(); o.type='sawtooth'; o.frequency.value=659.25;
          const g2 = ctx.createGain(); g2.gain.value = 0;
          o.connect(g2); g2.connect(ctx.destination);
          o.start(now + 0.12);
          g2.gain.linearRampToValueAtTime(0.18, now+0.14);
          g2.gain.linearRampToValueAtTime(0.0, now+1.3);
          o.stop(now+1.35);
        }
      } catch(e){ console.warn('sound failed', e); }
    }

    function clearCelebration(){
      if (_celebrationInterval) { clearInterval(_celebrationInterval); _celebrationInterval = null; }
      if (_celebrationTimeout) { clearTimeout(_celebrationTimeout); _celebrationTimeout = null; }
      if (celebrationContainer) {
        // stop any audio element
        const audioEl = document.getElementById('celebrationAudio');
        if (audioEl) {
          try { audioEl.pause(); audioEl.currentTime = 0; } catch(e){}
          audioEl.remove();
        }
        celebrationContainer.style.display = 'none';
        celebrationContainer.innerHTML = '';
        celebrationContainer.setAttribute('aria-hidden','true');
      }
    }

    function showCelebration(partNumbers, all=false){
      // clear any existing
      clearCelebration();

      const overlay = celebrationContainer;
      overlay.innerHTML = '';
      overlay.style.display = 'flex';
      overlay.setAttribute('aria-hidden','false');

      const center = document.createElement('div');
      center.className = 'celebration-center';

      // close button (bigger & elevated)
      const closeBtn = document.createElement('button');
      closeBtn.className = 'celebration-close';
      closeBtn.innerHTML = '✕';
      closeBtn.title = 'Close';
      closeBtn.addEventListener('click', ()=> {
        clearCelebration();
      });
      center.appendChild(closeBtn);

      // timer badge (15s countdown)
      const timerBadge = document.createElement('div');
      timerBadge.className = 'celebration-timer';
      center.appendChild(timerBadge);

      if (all) {
        const msg = document.createElement('div');
        msg.style.fontSize = '22px';
        msg.style.marginTop = '8px';
        msg.innerHTML = '🏆 🎉 You got 100% in All Parts, You are the Master NOW!!! 🎉 🏆';
        center.appendChild(msg);
        const sub = document.createElement('div'); sub.className = 'small'; sub.style.marginTop='8px'; sub.textContent = 'Press ✕ to close';
        center.appendChild(sub);
      } else {
        const partsText = partNumbers.join('&');
        const msg = document.createElement('div');
        msg.style.fontSize = '20px';
        msg.style.marginTop = '8px';
        // add several non-breaking spaces after "Good Job!" as requested
        msg.innerHTML = `🎶 You got 100% in Part ${partsText}, Good Job!&nbsp;&nbsp;&nbsp;&nbsp; 🎶`;
        center.appendChild(msg);
        const sub = document.createElement('div'); sub.className = 'small'; sub.style.marginTop='8px'; sub.textContent = 'Press ✕ to close';
        center.appendChild(sub);
      }

      // floating bursts (pointer-events:none)
      const emojis = ['🎵','🎶','🎼','🎹','🎻','🎷','🥁','🎺','🎸','🎧'];
      for (let i=0;i<14;i++){
        const e = document.createElement('div');
        e.className = 'celebration-burst';
        e.style.left = (10 + Math.random()*80) + '%';
        e.style.top = (60 + Math.random()*30) + '%';
        e.style.fontSize = (18 + Math.random()*36) + 'px';
        e.textContent = emojis[Math.floor(Math.random()*emojis.length)];
        e.style.animationDelay = (Math.random()*1.2) + 's';
        overlay.appendChild(e);
      }

      // create and play cheer audio (looping) from main branch cheer.mp3 (user requested)
      try {
        const audioEl = document.createElement('audio');
        audioEl.id = 'celebrationAudio';
        audioEl.src = 'https://cdn.jsdelivr.net/gh/dustmana8-byte/Auralis@main/cheer.mp3';
        audioEl.loop = true;
        audioEl.autoplay = true;
        audioEl.style.display = 'none';
        try { audioEl.volume = 0.8; } catch(e){}
        overlay.appendChild(audioEl);
        audioEl.play().catch(()=>{ /* may be blocked until user gesture */ });
      } catch(e){
        console.warn('failed to create celebration audio', e);
      }

      overlay.appendChild(center);

      // 15-second countdown with visible badge; auto-close when reaches 0
      let seconds = 15;
      timerBadge.textContent = `Closing in ${seconds}s`;
      _celebrationInterval = setInterval(()=>{
        seconds--;
        if (seconds <= 0) {
          clearCelebration();
        } else {
          timerBadge.textContent = `Closing in ${seconds}s`;
        }
      }, 1000);
      _celebrationTimeout = setTimeout(()=> clearCelebration(), (seconds+1)*1000);
    }

    // make nav items clickable for review (already done earlier)
    updateNavPresentation();

  </script>
</body>
</html>
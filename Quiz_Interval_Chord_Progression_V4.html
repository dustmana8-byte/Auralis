<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Music Ear Training for RCM Level 8 Exam (Sequence Mode)</title>
  <style>
    :root{
      --accent-green: #2ecc71; /* brighter green */
      --accent-green-strong: #21c46a;
      --accent-red: #ff4757;   /* brighter red */
      --accent-red-strong: #ff2d3a;
      --nav-bg: #f3f3f3;
      --nav-text-dim: #666;
    }

    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 1rem; max-width: 1000px; margin: auto; }
    h1 { margin-bottom:.2rem; }
    .controls-row { display:flex; gap:.5rem; align-items:center; margin-bottom: .6rem; flex-wrap:wrap; }
    /* choices layout and extra bottom padding so buttons don't overlap */
    .choices { display:flex; flex-direction:column; gap:.6rem; margin: .6rem 0; position:relative; padding-bottom:120px; }
    .choice-row { display:flex; gap:.6rem; }
    .choice-row.two { justify-content: flex-start; }
    .choice-row.single { justify-content: center; }
    /* Larger/taller buttons for touch devices to reduce mis-taps
       and allow multi-line centered content for progression labels */
    .choices button {
      padding:1rem 1rem;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      white-space:normal; /* allow wrapping / <br/> */
      font-size:1.05rem;
      min-width:160px;
      min-height:64px;
      flex:1;
      border-radius:10px;
    }
    .correct { background: #d4ffd4 !important; }
    .wrong { background: #ffd6d6 !important; }
    .hidden { display:none; }
    audio { width:100%; margin: .8rem 0; }
    label { font-weight:600; margin-right:.4rem; }
    #loginBox { border:1px solid #ddd; padding:1rem; border-radius:6px; margin-bottom:1rem; background:#fafafa; }
    #controls { margin-bottom: 0.8rem; }
    .nav-grid { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .nav-item { width:46px; height:46px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; background:var(--nav-bg); cursor:default; user-select:none; font-weight:800; color:var(--nav-text-dim); font-size:1rem; transition:transform .08s ease; box-shadow: 0 1px 0 rgba(0,0,0,0.03) inset; }
    .nav-item:hover { transform: translateY(-2px); }
    /* Brighter stronger colors and white text for contrast */
    .nav-item.correct { background: var(--accent-green); color: white; box-shadow: 0 6px 14px rgba(33,196,106,0.18); cursor:pointer; }
    .nav-item.wrong { background: var(--accent-red); color: white; box-shadow: 0 6px 14px rgba(255, 71, 87,0.18); cursor:pointer; }
    .nav-item.current { outline:3px solid rgba(0,0,0,0.08); transform: translateY(-1px); }
    .nav-item.presented { color:#111; background: #f1f1f1; cursor:default; }
    .nav-item.not-presented { color:#999; background:#fbfbfb; cursor:default; }
    .nav-section { margin-top:10px; }
    .nav-section-title { font-weight:700; margin-top:8px; margin-bottom:6px; }
    .small { font-size:0.9rem; color:#555; }
    .user-buttons { display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.5rem; }
    .user-buttons button { padding:.5rem .8rem; font-weight:600; }
    .other-input { display:flex; gap:.5rem; align-items:center; margin-top:.5rem; }
    select, button, input { font:inherit; }
    #serverResponse { margin-left: 0.6rem; color: #333; font-size: 0.95rem; }
    #wrongStats { margin-top: 0.8rem; background:#fff8f0; padding:.6rem; border-radius:6px; border:1px solid #f0d7c0; }
    #submitInfo { margin-top: .6rem; font-weight:600; }
    .section-title { margin-top: 0.8rem; font-weight:700; }
    .review-section { margin-top: 12px; border-top:1px dashed #ddd; padding-top:8px; }
    /* layout: main quiz content and a right-side small directory column on wide screens */
    .quiz-layout { display:flex; gap:1rem; align-items:flex-start; }
    .quiz-main { flex:1; min-width:0; position:relative; }
    .quiz-side { width:280px; flex-shrink:0; border-left:1px solid #eee; padding-left:16px; }
    @media (max-width:900px) {
      /* For narrow upright/mobile screens: show directory above the quiz,
         reduce gaps so things feel closer and more logical on upright mobile screens.
         IMPORTANT: remove 'sticky' behavior so the directory does NOT overlay the choices.
         Users will scroll between the directory and the choices (as requested). */
      .quiz-layout { flex-direction:column; gap:.5rem; }
      /* Place the directory before the main content on mobile so it's visible together with choices */
      .quiz-side { order: 0; width:100%; border-left:none; padding-left:0; padding-right:0; background:transparent; position:static; z-index:auto; border-bottom:none; margin-bottom:8px; }
      .quiz-main { order: 1; }
      .nav-grid { gap:6px; }
      .nav-item { width:40px; height:40px; font-size:.96rem; }
      .choices { padding-bottom:160px; }
    }

    /* Top play/next row (above choices) */
    .play-row { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:10px; }
    .play-left { display:flex; align-items:center; gap:12px; }
    /* Big visual play button (left) */
    #bigPlayBtn {
      width:96px;
      height:96px;
      border-radius:50%;
      background: linear-gradient(135deg,var(--accent-green),var(--accent-green-strong));
      display:inline-flex;
      align-items:center;
      justify-content:center;
      box-shadow: 0 8px 22px rgba(39,174,96,0.22), inset 0 -5px 10px rgba(0,0,0,0.06);
      cursor:pointer;
      user-select:none;
      flex-shrink:0;
    }
    #bigPlayBtn svg { width:54px; height:54px; fill:white; }
    #playCounter { font-weight:700; color:#222; font-size:0.95rem; }

    /* Big Next button (moved to top-right) */
    #bigNextBtn {
      width:86px;
      height:86px;
      border-radius:50%;
      background: linear-gradient(135deg,#3498db,#2c82d6);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      box-shadow: 0 8px 22px rgba(44,130,214,0.2), inset 0 -4px 8px rgba(0,0,0,0.06);
      cursor:pointer;
      user-select:none;
      flex-shrink:0;
    }
    #bigNextBtn svg { width:44px; height:44px; fill:white; }

    /* Copy button: bigger and decorated (bottom area) */
    #copyToDocBtn {
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:12px 18px;
      border-radius:12px;
      background: linear-gradient(135deg,#6a11cb,#2575fc);
      color: white;
      font-weight:800;
      font-size:1rem;
      box-shadow: 0 10px 30px rgba(37,117,252,0.18);
      border: none;
      cursor: pointer;
      margin-top:10px;
    }
    #copyToDocBtn svg { width:20px; height:20px; fill: white; }
    #copyToDocBtn:active { transform: translateY(1px); }

    /* Small fallback next hidden */
    #nextBtn { display:none; }
  </style>
</head>
<body>
  <h1>Music Ear Training for RCM Level 8 Exam (Sequence Mode)</h1>

  <div id="loginBox">
    <div><strong>Choose a user (no password required)</strong></div>
    <div class="user-buttons" style="margin-top:.6rem">
      <button id="btnBozart" type="button">Login as Bozart</button>
      <button id="btnTest" type="button">Login as Test</button>
    </div>

    <div class="other-input">
      <input id="otherName" placeholder="Other username (e.g. Alice)" />
      <button id="btnOther">Login as Other</button>
    </div>

    <div style="margin-top:.6rem">
      <button id="logoutBtn" class="hidden">Logout</button>
      <span id="loginMessage" style="margin-left:1rem;color:#444"></span>
      <span id="serverResponse"></span>
    </div>
  </div>

  <div id="controls" class="hidden">
    <div class="controls-row">
      <label>Mode:</label>
      <span class="small">Automatic sequence: Interval (N) → Chord (N) → Progression (N)</span>

      <label for="questionCount" style="margin-left:1rem">(Per-section count)</label>
      <input id="questionCount" type="number" min="1" value="10" style="width:5.2rem" />

      <button id="startBtn">Start Full Sequence</button>

      <div class="user-info" id="currentUserDisplay" style="margin-left:auto;font-weight:600"></div>
    </div>
    <div class="small">The quiz will present Interval questions first, then Chord, then Progression. The directory on the right shows progress and will become clickable after you finish the full seque[...]
  </div>

  <p id="status" class="small"></p>

  <div id="quiz" class="hidden">
    <div class="quiz-layout">
      <div class="quiz-side" id="sideDirectory">
        <div><strong>Directory</strong></div>
        <!-- Directory description removed per request -->
        <div id="intervalSection" class="nav-section">
          <div class="nav-section-title">1. Interval Identification</div>
          <div id="intervalRow1" class="nav-grid"></div>
          <div id="intervalRow2" class="nav-grid" style="margin-top:6px"></div>
        </div>

        <div id="chordSection" class="nav-section">
          <div class="nav-section-title">2. Chord Identification</div>
          <div id="chordRow1" class="nav-grid"></div>
          <div id="chordRow2" class="nav-grid" style="margin-top:6px"></div>
        </div>

        <div id="progSection" class="nav-section">
          <div class="nav-section-title">3. Chord Progression Identification</div>
          <div id="progRow1" class="nav-grid"></div>
          <div id="progRow2" class="nav-grid" style="margin-top:6px"></div>
        </div>
      </div>

      <div class="quiz-main">
        <div id="progress"></div>

        <audio id="player" preload="auto" controls></audio>

        <!-- Top row: Play on left, Next on right -->
        <div class="play-row" id="playRow" style="display:none;">
          <div class="play-left">
            <div id="bigPlayBtn" title="Play / Pause (tap to play)">
              <svg id="bigPlayIcon" viewBox="0 0 64 64" aria-hidden="true">
                <path d="M16 12v40l36-20z"></path>
              </svg>
            </div>
            <div id="playCounter" class="small">Plays: 0</div>
          </div>

          <div>
            <div id="bigNextBtn" title="Next / Finish" style="display:none;">
              <svg id="bigNextIcon" viewBox="0 0 64 64" aria-hidden="true">
                <path d="M18 12v40l16-20zM34 12v40h12V12z"></path>
              </svg>
            </div>
          </div>
        </div>

        <div class="choices" id="choices"></div>

        <div style="margin-top:.6rem;">
          <div id="resultNotice" style="margin-left:auto"></div>
        </div>

        <p id="feedback"></p>
        <p id="score" class="hidden"></p>

        <div id="submitInfo" class="hidden"></div>

        <div id="wrongStats" class="hidden"></div>

        <div id="copyContainer" class="hidden">
          <button id="copyToDocBtn" type="button" title="Copy results & open teacher doc">
            <!-- upload icon -->
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M5 20h14v-2H5v2zm7-18l-5 5h3v4h4V7h3l-5-5z"/></svg>
            Copy results & Open Google Doc
          </button>
          <span class="small" style="margin-left:.6rem">This copies the results to clipboard and opens the teacher's Google Doc for pasting.</span>
        </div>

        <div id="reviewNav" style="margin-top:12px" class="hidden">
          <div><strong>Review</strong></div>
          <!-- Review description removed per request -->
        </div>

        <div id="combinedReview" class="review-section hidden">
          <div class="section-title">All Quizzes Review</div>
          <div id="allReviewContainer"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // URLs and config
    const SHEET_WEBAPP_URL = "https://script.google.com/macros/s/AKfycbzS7uWPkIXHP94UG_7yrmLWL0VmArZgt084pgGgyzm2h-5Ad1PBOslSvXKQED_OOdd7HQ/exec";
    const TEACHER_DOC_URL = "https://docs.google.com/document/d/17P6DXWNvD-umI-M25iDnMJUewdUgNdkCDyruUeWgDts/edit?usp=sharing";

    // mapping and choices
    const codeToName = {
      "mi2":"minor 2nd","ma2":"Major 2nd","mi3":"minor 3rd","ma3":"Major 3rd",
      "p4":"Perfect 4th","a4":"Augmented 4th","p5":"Perfect 5th",
      "mi6":"minor 6th","ma6":"Major 6th","mi7":"minor 7th","ma7":"Major 7th",
      "ma":"Major Triad","mi":"minor Triad","a":"Augmented Triad","dom":"Dominant 7th","dim":"diminished 7th"
    };
    const INTERVAL_CHOICE_ROWS = [
      ["mi2", "ma2"],
      ["mi3", "ma3"],
      ["p4", "p5"],
      ["a4"],
      ["mi6", "ma6"],
      ["mi7", "ma7"]
    ];
    const CHORD_CHOICE_ROWS = [
      ["ma", "mi"],
      ["a"],
      ["dom", "dim"]
    ];
    const PROG_CHOICE_ROWS = [
      ["TSDT","tsDt"],
      ["TSDb","tsDB"],
      ["TbSD","tBsD"],
      ["TbST","tBst"]
    ];
    const PROG_CODE_TO_NAME = {
      "TSDT":"I-IV-V-I / Major 1-4-5-1",
      "tsDt":"i-iv-V-i / minor 1-4-5-1",
      "TSDb":"I-IV-V-vi / Major 1-4-5-6",
      "tsDB":"i-iv-V-VI / minor 1-4-5-6",
      "TbSD":"I-vi-IV-V / Major 1-6-4-5",
      "tBsD":"i-VI-iv-V / minor 1-6-4-5",
      "TbST":"I-vi-IV-I / Major 1-6-4-1",
      "tBst":"i-VI-iv-i / minor 1-6-4-1"
    };

    // storage keys and session containers
    const ACCOUNTS_KEY = "auralis_accounts_v1";
    const sessionResults = { interval: null, chord: null, progression: null };
    const lastQuestionsByType = { interval: null, chord: null, progression: null };

    // DOM refs
    const btnBozart = document.getElementById('btnBozart');
    const btnTest = document.getElementById('btnTest');
    const btnOther = document.getElementById('btnOther');
    const otherName = document.getElementById('otherName');
    const logoutBtn = document.getElementById('logoutBtn');
    const loginMessage = document.getElementById('loginMessage');
    const serverResponseEl = document.getElementById('serverResponse');
    const controls = document.getElementById('controls');
    const currentUserDisplay = document.getElementById('currentUserDisplay');
    const startBtn = document.getElementById('startBtn');
    const statusEl = document.getElementById('status');
    const questionCountInput = document.getElementById('questionCount');

    const choicesDiv = document.getElementById('choices');
    const player = document.getElementById('player');
    const bigPlayBtn = document.getElementById('bigPlayBtn');
    const bigPlayIcon = document.getElementById('bigPlayIcon');
    const playCounterEl = document.getElementById('playCounter');
    const playRow = document.getElementById('playRow');
    const bigNextBtn = document.getElementById('bigNextBtn');
    const bigNextIcon = document.getElementById('bigNextIcon');
    const progressEl = document.getElementById('progress');
    const feedback = document.getElementById('feedback');
    const scoreP = document.getElementById('score');
    const wrongStatsEl = document.getElementById('wrongStats');
    const submitInfo = document.getElementById('submitInfo');
    const copyContainer = document.getElementById('copyContainer');
    const copyToDocBtn = document.getElementById('copyToDocBtn');

    const intervalRow1 = document.getElementById('intervalRow1');
    const intervalRow2 = document.getElementById('intervalRow2');
    const chordRow1 = document.getElementById('chordRow1');
    const chordRow2 = document.getElementById('chordRow2');
    const progRow1 = document.getElementById('progRow1');
    const progRow2 = document.getElementById('progRow2');

    const reviewNav = document.getElementById('reviewNav');
    const combinedReview = document.getElementById('combinedReview');
    const allReviewContainer = document.getElementById('allReviewContainer');

    // helper storage
    function loadAccounts(){ try{ return JSON.parse(localStorage.getItem(ACCOUNTS_KEY) || "{}"); }catch(e){return{}} }
    function saveAccounts(obj){ localStorage.setItem(ACCOUNTS_KEY, JSON.stringify(obj)); }

    (function ensureDemoAccounts(){
      const a = loadAccounts();
      if (!a["Bozart"]) a["Bozart"] = { results: [] };
      if (!a["Test"]) a["Test"] = { results: [] };
      saveAccounts(a);
    })();

    // login handlers
    let currentUser = null;
    btnBozart.addEventListener('click', ()=> loginAs('Bozart'));
    btnTest.addEventListener('click', ()=> loginAs('Test'));
    btnOther.addEventListener('click', ()=> {
      const v = (otherName.value || "").trim();
      if (!v) { alert('Enter a username first'); return; }
      loginAs(v);
    });
    logoutBtn.addEventListener('click', ()=> {
      currentUser = null;
      loginMessage.textContent = "Logged out.";
      serverResponseEl.textContent = "";
      btnBozart.disabled = false; btnTest.disabled = false; btnOther.disabled = false; otherName.disabled = false;
      logoutBtn.classList.add('hidden');
      controls.classList.add('hidden');
      currentUserDisplay.textContent = "";
      document.getElementById('quiz').classList.add('hidden');
      sessionResults.interval = sessionResults.chord = sessionResults.progression = null;
      lastQuestionsByType.interval = lastQuestionsByType.chord = lastQuestionsByType.progression = null;
    });

    function loginAs(name){
      const accounts = loadAccounts();
      if (!accounts[name]) accounts[name] = { results: [] };
      saveAccounts(accounts);
      currentUser = name;
      loginMessage.textContent = `Logged in as ${name}.`;
      serverResponseEl.textContent = "";
      btnBozart.disabled = true; btnTest.disabled = true; btnOther.disabled = true; otherName.disabled = true;
      logoutBtn.classList.remove('hidden');
      controls.classList.remove('hidden');
      currentUserDisplay.textContent = `User: ${currentUser}`;
      if (filesLoadedByBranch['audio'] && filesLoadedByBranch['Chord'] && filesLoadedByBranch['Progression']) startBtn.disabled = false;
    }

    // file helpers
    function extractPrefixes(filename){
      const base = filename.split('/').pop();
      const raw = (base.split('_')[0] || "");
      const lower = raw.toLowerCase();
      return { raw, lower };
    }
    function jsDelivrUrlForBranch(branch, filename){
      return `https://cdn.jsdelivr.net/gh/dustmana8-byte/Auralis@${encodeURIComponent(branch)}/${encodeURIComponent(filename)}`;
    }
    function shuffle(a){ for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

    // load files per branch
    const allFilesByBranch = {};
    const filesLoadedByBranch = {};
    async function loadFiles(branch){
      statusEl.textContent = `Loading audio files for branch "${branch}"...`;
      try{
        const api = `https://api.github.com/repos/dustmana8-byte/Auralis/contents?ref=${encodeURIComponent(branch)}`;
        const r = await fetch(api);
        if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
        const data = await r.json();
        const mp3s = data.filter(f => f.type === "file" && f.name.toLowerCase().endsWith('.mp3'));
        const files = mp3s.map(f => {
          const { raw, lower } = extractPrefixes(f.name);
          const displayName = codeToName[lower] || f.name;
          return { name: f.name, url: jsDelivrUrlForBranch(branch, f.name), rawKey: raw, key: lower, displayName };
        }).filter(x => x.rawKey);
        if (files.length === 0) {
          statusEl.textContent = `No usable mp3 files found in branch ${branch}.`;
          filesLoadedByBranch[branch] = false;
          return;
        }
        allFilesByBranch[branch] = files;
        filesLoadedByBranch[branch] = true;
        statusEl.textContent = `Loaded ${files.length} audio files from branch "${branch}".`;
        if (currentUser && filesLoadedByBranch['audio'] && filesLoadedByBranch['Chord'] && filesLoadedByBranch['Progression']) startBtn.disabled = false;
      } catch(err){
        statusEl.textContent = "Failed to load audio files: " + err.message;
        console.error(err);
        filesLoadedByBranch[branch] = false;
      }
    }

    (async function init(){
      startBtn.disabled = true;
      await loadFiles('audio');
      loadFiles('Chord').catch(()=>{});
      loadFiles('Progression').catch(()=>{});
    })();

    // audio preloading
    const audioContext = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;
    const preloadedMap = new Map(); // url -> objectUrl
    async function ensureBuffered(url){
      if (preloadedMap.has(url)) return preloadedMap.get(url);
      try {
        const resp = await fetch(url, {mode: 'cors'});
        if (!resp.ok) throw new Error('fetch failed ' + resp.status);
        const arrayBuffer = await resp.arrayBuffer();
        if (audioContext && audioContext.state !== 'suspended') {
          audioContext.decodeAudioData(arrayBuffer.slice(0), ()=>{}, ()=>{});
        }
        const blob = new Blob([arrayBuffer], { type: 'audio/mpeg' });
        const objectUrl = URL.createObjectURL(blob);
        preloadedMap.set(url, objectUrl);
        return objectUrl;
      } catch(err) {
        console.warn('Preload failed, fallback to original URL', err);
        return url;
      }
    }

    // quiz flow (combined)
    let questions = [], currentIdx = 0, presentedCount = 0, quizFinished = false;

    function buildCombinedQuestions(perSectionCount){
      questions = [];
      function pickFromBranch(branch, count, sectionName, mapCorrectKeyIsRaw=false){
        const pool = shuffle((allFilesByBranch[branch] || []).slice());
        for (let i=0;i<count;i++){
          if (pool.length===0) pool.push(...shuffle((allFilesByBranch[branch] || []).slice()));
          const file = pool.pop();
          const correctKey = mapCorrectKeyIsRaw ? file.rawKey : file.key;
          questions.push({ section: sectionName, file, correctKey, selectedKey: null, playCount: 0, _answered: false });
        }
      }
      pickFromBranch('audio', perSectionCount, 'interval', false);
      pickFromBranch('Chord', perSectionCount, 'chord', false);
      pickFromBranch('Progression', perSectionCount, 'progression', true);
    }

    startBtn.addEventListener('click', ()=>{
      if (!currentUser) { alert("Please login first"); return; }
      const perSectionCount = Math.max(1, parseInt(questionCountInput.value,10) || 10);
      if (!filesLoadedByBranch['audio'] || !filesLoadedByBranch['Chord'] || !filesLoadedByBranch['Progression']) {
        alert('Audio files for all branches are not ready yet. Please wait a moment for loading to finish.');
        return;
      }
      buildCombinedQuestions(perSectionCount);
      currentIdx = 0;
      presentedCount = 1;
      quizFinished = false;
      document.getElementById('quiz').classList.remove('hidden');
      scoreP.classList.add('hidden');
      reviewNav.classList.remove('hidden');
      wrongStatsEl.classList.add('hidden');
      submitInfo.classList.add('hidden');
      copyContainer.classList.add('hidden');
      combinedReview.classList.add('hidden');
      populateSequenceNav(perSectionCount);

      // show top play/next row
      playRow.style.display = 'flex';
      document.getElementById('bigNextBtn').style.display = 'none'; // hidden until a choice is made

      // pre-buffer first file and set src
      ensureBuffered(questions[0].file.url).then(objUrl => {
        player.src = objUrl || questions[0].file.url;
        player.load();
      }).catch(()=>{ player.src = questions[0].file.url; player.load(); });

      // render first question (renderQuestion is async but we don't need to await here)
      renderQuestion(currentIdx, false);
      updateNavPresentation();
    });

    // build directory with labeled indices
    function populateSequenceNav(perSectionCount){
      [intervalRow1, intervalRow2, chordRow1, chordRow2, progRow1, progRow2].forEach(r => r.innerHTML = '');
      const countI = questions.filter(q=>q.section==='interval').length;
      const countC = questions.filter(q=>q.section==='chord').length;
      const countP = questions.filter(q=>q.section==='progression').length;

      function makeEl(label, idx){
        const d = document.createElement('div');
        d.className = 'nav-item not-presented';
        d.textContent = label;
        d.dataset.index = idx;
        return d;
      }

      for (let i=0;i<countI;i++){
        const idx = i;
        const label = `1.${i+1}`;
        const el = makeEl(label, idx);
        if (i < Math.ceil(countI/2)) intervalRow1.appendChild(el); else intervalRow2.appendChild(el);
      }
      const offsetC = countI;
      for (let i=0;i<countC;i++){
        const idx = offsetC + i;
        const label = `2.${i+1}`;
        const el = makeEl(label, idx);
        if (i < Math.ceil(countC/2)) chordRow1.appendChild(el); else chordRow2.appendChild(el);
      }
      const offsetP = countI + countC;
      for (let i=0;i<countP;i++){
        const idx = offsetP + i;
        const label = `3.${i+1}`;
        const el = makeEl(label, idx);
        if (i < Math.ceil(countP/2)) progRow1.appendChild(el); else progRow2.appendChild(el);
      }
      updateNavPresentation();
    }

    // Update directory presentation; after finish show green/red; during quiz show presented/not-presented
    function updateNavPresentation(){
      const containers = [intervalRow1, intervalRow2, chordRow1, chordRow2, progRow1, progRow2];
      containers.forEach(container=>{
        Array.from(container.children).forEach(node=>{
          const idx = parseInt(node.dataset.index,10);
          node.classList.remove('presented','not-presented','current','correct','wrong');
          const q = questions[idx];
          if (quizFinished){
            if (!q || !q.selectedKey) {
              node.classList.add('not-presented');
              node.style.cursor = 'default';
            } else {
              if (q.selectedKey === q.correctKey) { node.classList.add('correct'); node.style.cursor='pointer'; }
              else { node.classList.add('wrong'); node.style.cursor='pointer'; }
            }
          } else {
            if (idx < presentedCount) { node.classList.add('presented'); node.style.cursor='default'; } else { node.classList.add('not-presented'); node.style.cursor='default'; }
          }
        });
      });
      updateNavHighlight();
    }
    function updateNavHighlight(){
      [intervalRow1, intervalRow2, chordRow1, chordRow2, progRow1, progRow2].forEach(container=>Array.from(container.children).forEach(n=>n.classList.remove('current')));
      const cur = document.querySelector(`[data-index="${currentIdx}"]`);
      if (cur) cur.classList.add('current');
    }

    // play counter
    function updatePlayCounter(){
      const q = questions[currentIdx];
      playCounterEl.textContent = `Plays: ${q ? (q.playCount || 0) : 0}`;
    }

    // show/hide top Next
    function showTopNext(){
      const n = document.getElementById('bigNextBtn');
      n.style.display = 'inline-flex';
    }
    function hideTopNext(){
      const n = document.getElementById('bigNextBtn');
      n.style.display = 'none';
    }

    // render question (choices) - careful to mark clicked button red/green immediately
    // make async so we can attempt autoplay after load
    async function renderQuestion(idx, reviewing=false){
      const q = questions[idx];
      const sameBefore = questions.slice(0, idx).filter(x=>x.section===q.section).length;
      const sectionPos = sameBefore + 1;
      const sectionTotal = questions.filter(x=>x.section===q.section).length;
      progressEl.textContent = `${q.section.toUpperCase()} Question ${sectionPos} / ${sectionTotal}  (Overall ${idx+1} / ${questions.length})`;
      feedback.textContent = "";
      choicesDiv.innerHTML = "";
      hideTopNext();

      // show the top row
      playRow.style.display = 'flex';

      // preload and set player src (buffered)
      try {
        const objUrl = await ensureBuffered(q.file.url);
        player.src = objUrl || q.file.url;
        player.load();
      } catch(e){
        player.src = q.file.url;
        player.load();
      }

      // pre-buffer next
      const next = questions[idx+1];
      if (next) ensureBuffered(next.file.url).catch(()=>{});

      updatePlayCounter();

      // helper for common choice button creation to ensure correct/wrong marking logic is uniform
      function makeChoiceButton(key, label, isHtml = false){
        const btn = document.createElement('button');
        btn.type = 'button';
        if (isHtml) btn.innerHTML = label;
        else btn.textContent = label;
        btn.dataset.key = key;
        return btn;
      }

      if (q.section === 'progression'){
        const availableRaw = new Set((allFilesByBranch['Progression']||[]).map(f=>f.rawKey));
        PROG_CHOICE_ROWS.forEach(row=>{
          const rowKeys = row.filter(k=>availableRaw.has(k));
          if (rowKeys.length===0) return;
          const rowDiv = document.createElement('div'); rowDiv.className='choice-row ' + (rowKeys.length===1 ? 'single':'two');
          rowKeys.forEach(k=>{
            const rawLabel = (PROG_CODE_TO_NAME[k] || k).toString();
            const labelHtml = rawLabel.replace(/\s*\/\s*/, '<br/>');
            const btn = makeChoiceButton(k, labelHtml, true);
            if (reviewing || q.selectedKey !== null || quizFinished){
              btn.disabled = true;
              if (quizFinished){
                if (k === q.correctKey) btn.classList.add('correct');
                if (q.selectedKey && k === q.selectedKey && q.selectedKey !== q.correctKey) btn.classList.add('wrong');
              } else {
                if (k === q.correctKey) btn.classList.add('correct');
              }
            } else {
              btn.addEventListener('click', ()=>{
                q.selectedKey = k;
                q._answered = true; // stop counting further plays for this question
                if (k === q.correctKey) btn.classList.add('correct'); else btn.classList.add('wrong');
                Array.from(rowDiv.parentElement.querySelectorAll('button')).forEach(b=>{
                  b.disabled = true;
                  if (b.dataset.key === q.correctKey) b.classList.add('correct');
                });
                const label = (idx === questions.length-1) ? "Finish" : "Next";
                showTopNext();
              });
            }
            rowDiv.appendChild(btn);
          });
          choicesDiv.appendChild(rowDiv);
        });
      } else if (q.section === 'chord'){
        const availableKeys = new Set((allFilesByBranch['Chord']||[]).map(f=>f.key));
        CHORD_CHOICE_ROWS.forEach(row=>{
          const rowKeys = row.filter(k=>availableKeys.has(k));
          if (rowKeys.length===0) return;
          const rowDiv = document.createElement('div'); rowDiv.className='choice-row ' + (rowKeys.length===1 ? 'single':'two');
          rowKeys.forEach(k=>{
            const btn = makeChoiceButton(k, codeToName[k] || k);
            if (reviewing || q.selectedKey !== null || quizFinished){
              btn.disabled = true;
              if (quizFinished){
                if (k === q.correctKey) btn.classList.add('correct');
                if (q.selectedKey && k === q.selectedKey && q.selectedKey !== q.correctKey) btn.classList.add('wrong');
              } else {
                if (k === q.correctKey) btn.classList.add('correct');
              }
            } else {
              btn.addEventListener('click', ()=>{
                q.selectedKey = k;
                q._answered = true;
                if (k === q.correctKey) btn.classList.add('correct'); else btn.classList.add('wrong');
                Array.from(rowDiv.parentElement.querySelectorAll('button')).forEach(b=>{
                  b.disabled = true;
                  if (b.dataset.key === q.correctKey) b.classList.add('correct');
                });
                const label = (idx === questions.length-1) ? "Finish" : "Next";
                showTopNext();
              });
            }
            rowDiv.appendChild(btn);
          });
          choicesDiv.appendChild(rowDiv);
        });
      } else { // interval
        const availableKeys = new Set((allFilesByBranch['audio']||[]).map(f=>f.key));
        INTERVAL_CHOICE_ROWS.forEach(row=>{
          const rowKeys = row.filter(k=>availableKeys.has(k));
          if (rowKeys.length===0) return;
          const rowDiv = document.createElement('div'); rowDiv.className='choice-row ' + (rowKeys.length===1 ? 'single':'two');
          rowKeys.forEach(k=>{
            const btn = makeChoiceButton(k, codeToName[k] || k);
            if (reviewing || q.selectedKey !== null || quizFinished){
              btn.disabled = true;
              if (quizFinished){
                if (k === q.correctKey) btn.classList.add('correct');
                if (q.selectedKey && k === q.selectedKey && q.selectedKey !== q.correctKey) btn.classList.add('wrong');
              } else {
                if (k === q.correctKey) btn.classList.add('correct');
              }
            } else {
              btn.addEventListener('click', ()=>{
                q.selectedKey = k;
                q._answered = true;
                if (k === q.correctKey) btn.classList.add('correct'); else btn.classList.add('wrong');
                Array.from(rowDiv.parentElement.querySelectorAll('button')).forEach(b=>{
                  b.disabled = true;
                  if (b.dataset.key === q.correctKey) b.classList.add('correct');
                });
                const label = (idx === questions.length-1) ? "Finish" : "Next";
                showTopNext();
              });
            }
            rowDiv.appendChild(btn);
          });
          choicesDiv.appendChild(rowDiv);
        });
      }

      if (idx >= presentedCount) presentedCount = idx + 1;
      updateNavPresentation();
      updateNavHighlight();

      // attempt to autoplay when a question is shown (skip when reviewing)
      if (!reviewing) {
        try {
          // play() may be blocked by browser policies until user gesture (login/start)
          await player.play().catch(()=>{ /* autoplay blocked */ });
        } catch(e){
          // ignore
        }
      }
    }

    // audio event handlers to increment play count
    player.addEventListener('play', ()=>{
      const q = questions[currentIdx];
      if (!q) return;
      // Only increment while quiz is ongoing AND before the user has answered this question.
      if (!quizFinished && !q._answered) {
        q.playCount = (q.playCount || 0) + 1;
        updatePlayCounter();
      }
      // swap play icon to pause
      bigPlayIcon.innerHTML = '<path d="M20 12h8v40h-8zM36 12h8v40h-8z"></path>';
    });
    player.addEventListener('pause', ()=> { bigPlayIcon.innerHTML = '<path d="M16 12v40l36-20z"></path>'; });
    player.addEventListener('ended', ()=> { bigPlayIcon.innerHTML = '<path d="M16 12v40l36-20z"></path>'; });

    // big play toggle
    bigPlayBtn.addEventListener('click', async ()=>{
      try {
        if (player.paused) await player.play(); else player.pause();
      } catch(err){ alert('Playback failed: ' + (err && err.message ? err.message : err)); }
    });

    // big next action
    async function handleTopNext(){
      // hide the top next control
      document.getElementById('bigNextBtn').style.display = 'none';
      // if last question -> finalize
      if (currentIdx >= questions.length - 1) { await finalizeCombinedQuiz(); return; }
      currentIdx++;
      const q = questions[currentIdx];
      ensureBuffered(q.file.url).then(objUrl=>{
        player.src = objUrl || q.file.url;
        player.load();
      }).catch(()=>{ player.src = q.file.url; player.load(); });
      renderQuestion(currentIdx, false);
    }
    bigNextBtn.addEventListener('click', handleTopNext);

    // finalize combined quiz
    async function finalizeCombinedQuiz(){
      quizFinished = true;
      // compute per-section
      const sections = { interval: { score:0, total:0, questionDetails:[], wrongCounts:{} },
                         chord: { score:0, total:0, questionDetails:[], wrongCounts:{} },
                         progression: { score:0, total:0, questionDetails:[], wrongCounts:{} } };
      questions.forEach(q=>{
        const sec = sections[q.section];
        sec.total++;
        if (q.selectedKey === q.correctKey) sec.score++;
        else sec.wrongCounts[q.correctKey] = (sec.wrongCounts[q.correctKey] || 0) + 1;
        sec.questionDetails.push({ correctKey: q.correctKey, selectedKey: q.selectedKey || null, fileName: q.file.name, playCount: q.playCount || 0 });
      });

      const timestamp = new Date().toISOString();

      // save locally
      const accounts = loadAccounts();
      if (!accounts[currentUser]) accounts[currentUser] = { results: [] };

      Object.keys(sections).forEach(secKey=>{
        const sec = sections[secKey];
        const record = {
          quizType: secKey,
          score: sec.score,
          total: sec.total,
          date: timestamp,
          questionDetails: sec.questionDetails,
          wrongCounts: sec.wrongCounts
        };
        accounts[currentUser].results.push(record);
        sessionResults[secKey] = record;
        lastQuestionsByType[secKey] = questions.filter(q=>q.section===secKey).map(q=>({ ...q }));
        // send to sheet (best-effort)
        sendResultToSheet({
          uid: currentUser,
          email: currentUser + "@example.com",
          quizType: secKey,
          score: sec.score,
          total: sec.total,
          wrongCounts: sec.wrongCounts,
          questionDetails: sec.questionDetails,
          date: timestamp
        }).then(ok => {
          if (ok) serverResponseEl.textContent = "Sheet: saved ✓";
          else serverResponseEl.textContent = "Sheet: failed to save";
        });
      });

      saveAccounts(accounts);

      // combined summary
      const totalCorrect = sections.interval.score + sections.chord.score + sections.progression.score;
      const totalQuestions = sections.interval.total + sections.chord.total + sections.progression.total;
      scoreP.textContent = `Combined score: ${totalCorrect} / ${totalQuestions} (${Math.round(1000*totalCorrect/totalQuestions)/10}%).`;
      scoreP.classList.remove('hidden');

      submitInfo.textContent = `Submitted by: ${currentUser}  —  Time: ${timestamp}  — Full sequence`;
      submitInfo.classList.remove('hidden');

      // wrong stats
      wrongStatsEl.innerHTML = "";
      Object.keys(sections).forEach(secKey=>{
        const sec = sections[secKey];
        const secTitle = secKey === 'interval' ? 'Interval' : secKey === 'chord' ? 'Chord' : 'Progression';
        wrongStatsEl.innerHTML += `<strong>${secTitle} — Score: ${sec.score} / ${sec.total}</strong><br/>`;
        const wrongs = sec.questionDetails.filter(qd => qd.selectedKey && qd.selectedKey !== qd.correctKey);
        if (wrongs.length > 0) {
          const ul = document.createElement('ul');
          wrongs.forEach(w=>{
            const li = document.createElement('li');
            const correctLabel = secKey === 'progression' ? (PROG_CODE_TO_NAME[w.correctKey] || w.correctKey) : (codeToName[w.correctKey] || w.correctKey);
            const selectedLabel = secKey === 'progression' ? (PROG_CODE_TO_NAME[w.selectedKey] || w.selectedKey) : (codeToName[w.selectedKey] || w.selectedKey);
            li.textContent = `File: ${w.fileName} — Correct: "${correctLabel}" — Selected: "${selectedLabel}" — Plays: ${w.playCount || 0}`;
            ul.appendChild(li);
          });
          wrongStatsEl.appendChild(ul);
        } else {
          wrongStatsEl.innerHTML += "No wrong items — well done!<br/>";
        }
        wrongStatsEl.innerHTML += "<br/>";
      });
      wrongStatsEl.classList.remove('hidden');

      // make directory interactive and keep coloring when clicked (fix bug #2)
      makeDirectoryInteractiveAndColor();

      // show copy area and review
      copyContainer.classList.remove('hidden');
      copyToDocBtn.onclick = async ()=> { await copyResultsAndOpenDocCombined(TEACHER_DOC_URL); };
      combinedReview.classList.remove('hidden');
      populateCombinedReview();

      // hide top next
      hideTopNext();
    }

    // Ensure directory items keep colors when clicked and navigate for review
    function makeDirectoryInteractiveAndColor(){
      const containers = [intervalRow1, intervalRow2, chordRow1, chordRow2, progRow1, progRow2];
      containers.forEach(container=>{
        Array.from(container.children).forEach(node=>{
          const idx = parseInt(node.dataset.index,10);
          const q = questions[idx];
          // clear previous handlers by cloning
          const newNode = node.cloneNode(true);
          node.parentNode.replaceChild(newNode, node);
          // apply classes fresh
          newNode.classList.remove('presented','not-presented','current','correct','wrong');
          if (!q || !q.selectedKey) {
            newNode.classList.add('not-presented');
            newNode.style.cursor = 'default';
            return;
          }
          if (q.selectedKey === q.correctKey) newNode.classList.add('correct'); else newNode.classList.add('wrong');
          newNode.style.cursor = 'pointer';
          // attach click for review — preserve coloring
          newNode.addEventListener('click', ()=>{
            renderQuestion(idx, true); // review mode
            currentIdx = idx;
            updateNavHighlight();
          });
        });
      });
    }

    function populateCombinedReview(){
      allReviewContainer.innerHTML = "";
      const sections = [
        { key: 'interval', title: 'Interval Identification' },
        { key: 'chord', title: 'Chord Identification' },
        { key: 'progression', title: 'Chord Progression Identification' }
      ];
      sections.forEach(section=>{
        const res = sessionResults[section.key];
        const sectionDiv = document.createElement('div');
        sectionDiv.className = 'review-section';
        const h = document.createElement('div');
        h.className = 'section-title';
        const scoreText = res ? ` — Score: ${res.score} / ${res.total}` : '';
        h.textContent = section.title + scoreText;
        sectionDiv.appendChild(h);
        if (!res) {
          const p = document.createElement('div'); p.className='small'; p.textContent='Not taken in this session.'; sectionDiv.appendChild(p); allReviewContainer.appendChild(sectionDiv); return;
        }
        const ul = document.createElement('ul');
        res.questionDetails.forEach((qd,i)=>{
          const li = document.createElement('li');
          let correctLabel = qd.correctKey;
          let selectedLabel = qd.selectedKey || "(no answer)";
          if (section.key === 'progression') {
            correctLabel = PROG_CODE_TO_NAME[qd.correctKey] || qd.correctKey;
            selectedLabel = qd.selectedKey ? (PROG_CODE_TO_NAME[qd.selectedKey] || qd.selectedKey) : "(no answer)";
          } else {
            correctLabel = codeToName[qd.correctKey] || qd.correctKey;
            selectedLabel = qd.selectedKey ? (codeToName[qd.selectedKey] || qd.selectedKey) : "(no answer)";
          }
          li.textContent = `Q${i+1}: Correct: ${correctLabel} — Selected: ${selectedLabel} — Plays: ${qd.playCount || 0} — (${qd.fileName})`;
          ul.appendChild(li);
        });
        sectionDiv.appendChild(ul);
        allReviewContainer.appendChild(sectionDiv);
      });
    }

    // send to sheet (best-effort)
    async function sendResultToSheet(data){
      try {
        const res = await fetch(SHEET_WEBAPP_URL, {
          method:'POST',
          headers:{ 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        if (!res.ok) {
          console.error('Sheet POST failed', res.status, await res.text());
          return false;
        }
        const j = await res.json().catch(()=>null);
        if (j && j.ok === false) return false;
        return true;
      } catch(err){ console.error('Error sending to sheet:', err); return false; }
    }

    // copy combined results and open teacher doc
    async function copyResultsAndOpenDocCombined(docUrl){
      let text = "";
      text += "Auralis Combined Quiz Results\n";
      text += "-----------------------------\n";
      text += `User: ${currentUser}\n`;
      text += `Time: ${new Date().toISOString()}\n\n`;
      const sections = [
        { key: 'interval', title: '1) Interval Identification' },
        { key: 'chord', title: '2) Chord Identification' },
        { key: 'progression', title: '3) Chord Progression Identification' }
      ];
      sections.forEach(sec=>{
        const res = sessionResults[sec.key];
        text += `${sec.title}\n`;
        text += "-----------------\n";
        if (!res) { text += "Not taken in this session.\n\n"; return; }
        text += `Score: ${res.score} / ${res.total}\n\n`;
        text += "Question details:\n";
        res.questionDetails.forEach((qd,i)=>{
          let correctLabel = qd.correctKey;
          let selectedLabel = qd.selectedKey || "(no answer)";
          if (sec.key === 'progression') {
            correctLabel = PROG_CODE_TO_NAME[qd.correctKey] || qd.correctKey;
            selectedLabel = qd.selectedKey ? (PROG_CODE_TO_NAME[qd.selectedKey] || qd.selectedKey) : "(no answer)";
          } else {
            correctLabel = codeToName[qd.correctKey] || qd.correctKey;
            selectedLabel = qd.selectedKey ? (codeToName[qd.selectedKey] || qd.selectedKey) : "(no answer)";
          }
          text += `Q${i+1}: Correct: ${correctLabel}   Selected: ${selectedLabel}   Plays: ${qd.playCount || 0}   (file: ${qd.fileName})\n`;
        });
        const wrongs = res.questionDetails.filter(qd=>qd.selectedKey && qd.selectedKey !== qd.correctKey);
        if (wrongs.length>0){
          text += `\nWrong items summary:\n`;
          wrongs.forEach((qd,i)=>{
            const correctLabel = sec.key === 'progression' ? (PROG_CODE_TO_NAME[qd.correctKey] || qd.correctKey) : (codeToName[qd.correctKey] || qd.correctKey);
            const selectedLabel = sec.key === 'progression' ? (PROG_CODE_TO_NAME[qd.selectedKey] || qd.selectedKey) : (codeToName[qd.selectedKey] || qd.selectedKey);
            text += `Question ${i+1}: Correct: "${correctLabel}"  — Wrong Answer: "${selectedLabel}" — Plays: ${qd.playCount || 0} (file: ${qd.fileName})\n`;
          });
        } else {
          text += "\nNo wrong items — all correct.\n";
        }
        text += "\n";
      });
      text += `(You can paste this into the teacher's Google Doc: ${docUrl})\n`;

      try {
        await navigator.clipboard.writeText(text);
        window.open(docUrl, '_blank');
      } catch(e){
        alert('Copy failed: ' + (e && e.message ? e.message : e));
      }
    }

    // (other functions below remain unchanged...)
  </script>
</body>
</html>